{"version":3,"file":"lycabinet.light.min.js","mappings":"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","sources":["webpack://Lycabinet/webpack/universalModuleDefinition","webpack://Lycabinet/webpack/bootstrap","webpack://Lycabinet/webpack/runtime/define property getters","webpack://Lycabinet/webpack/runtime/hasOwnProperty shorthand","webpack://Lycabinet/./src/utils/util.ts","webpack://Lycabinet/./src/utils/status.js","webpack://Lycabinet/./src/light.js","webpack://Lycabinet/./src/core/store.ts","webpack://Lycabinet/./src/core/lycabinet.ts","webpack://Lycabinet/./src/core/lazy-support.ts","webpack://Lycabinet/./src/core/mixin.ts"],"sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"Lycabinet\", [], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"Lycabinet\"] = factory();\n\telse\n\t\troot[\"Lycabinet\"] = factory();\n})(self, function() {\nreturn ","// The require scope\nvar __webpack_require__ = {};\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","/**\r\n * Utils.js.\r\n * By lozyue.\r\n */\r\n\r\n/**\r\n * Get the item in an array with index. Support negative index.\r\n * @param  {...any} objs \r\n */\r\nexport const arrayIndex = function (arr, index) {\r\n  index = (arr.length + index) % arr.length;\r\n  if (arr[index] === undefined) {\r\n    console.log(arr, index);\r\n    throw new Error(`The index ${index} in array ${arr.toString()} is overflowed!`);\r\n  }\r\n  return arr[index];\r\n}\r\n\r\n/**\r\n * Centralized management.\r\n * Add a listener to window storage event.\r\n * @param { Function } invoke Target invoke function or handle. \r\n * @param { Boolean } remove wheather the action is to remove added storage listener.\r\n */\r\nexport const addStoreListener = (()=>{\r\n  const invokeQueue: Function[]= [];\r\n  window.addEventListener(\"storage\", (eve)=>{\r\n    invokeQueue.forEach(func=>{\r\n      func(eve);\r\n    });\r\n  }, false); // default bubble.\r\n\r\n  return (invoke, remove = false)=>{\r\n    if(remove) \r\n      removeArrayItem(invokeQueue, invoke);\r\n    else invokeQueue.push(invoke);\r\n  }\r\n})();\r\n\r\n/**\r\n * Deep Object.assign source to target.\r\n * @param target\r\n * @param source\r\n */\r\nexport const deepAssign = function (...objs) {\r\n  let merged;\r\n  objs.reduce((target, source) => {\r\n    for (let item in source) {\r\n      if (!(target[item] && is_PlainObject(target[item])) ) {\r\n        target[item] = source[item];\r\n      } else {\r\n        deepAssign(target[item], source[item]);\r\n      }\r\n    }\r\n    merged = target;\r\n    return target;\r\n  }, objs[0]); // The third param is to set default value.\r\n  return merged;\r\n}\r\n\r\n/**\r\n * Just assign the item in supplement which not defined in target.\r\n * If you don't want to override the value of origin Object, supplement is the high performance choice.\r\n * Not deep mode.\r\n * @param {*} target \r\n * @param {*} supplement \r\n */\r\nexport function objectSupplement(target, supplement) {\r\n  let current = null;\r\n  for (let item in supplement) {\r\n    current = target[item];\r\n    if (is_Defined(current))\r\n      continue;\r\n    target[item] = supplement[item];\r\n  }\r\n  return target;\r\n}\r\n\r\n/**\r\n * Just assign the item in supplement which not defined in target.\r\n * If you don't want to override the value of origin Object, supplement is the high performance choice.\r\n * Deep mode by iterate each inner Object.\r\n * @param {*} target \r\n * @param {*} supplement \r\n */\r\nexport function deepSupplement(target, supplement) {\r\n  let current = null;\r\n  for (let item in supplement) {\r\n    current = target[item];\r\n    if (is_Defined(current)) {\r\n      if (!is_PlainObject(current)) continue;\r\n      deepSupplement(current, supplement[item]); // The `current` is a reference which could be assigned.\r\n    }\r\n    else\r\n      // current = supplement[item];\r\n      target[item] = supplement[item];\r\n  }\r\n  return target;\r\n}\r\n\r\n\r\n/**\r\n * Simple deepClone with optional Function clone\r\n */\r\nexport function deepClone(val, substituteObj = Object.create(null), cloneFunc = true) {\r\n  if (is_PlainObject(val)) {\r\n    var res = substituteObj;\r\n    for (var key in val) {\r\n      res[key] = deepClone(val[key]);\r\n    }\r\n    return res;\r\n  } else if (is_Array(val)) {\r\n    return val.slice()\r\n  } else if (cloneFunc && is_Function(val)) {\r\n    return Object.create(val.prototype).constructor;\r\n  } else {\r\n    return val;\r\n  }\r\n}\r\n\r\nexport function iterateObject(source: Object, iterate: Function){\r\n  iterate(source);\r\n  for(let item in source){\r\n    if( is_PlainObject(source[item]) )\r\n      iterate(source, iterate);\r\n  }\r\n}\r\n\r\nexport const is_Defined = (v: any):Boolean => (v !== undefined && v !== null);\r\nexport const is_PlainObject = (obj) => (Object.prototype.toString.call(obj) === '[object Object]');\r\nexport const is_Array = (obj) => (Array.isArray && Array.isArray(obj) || (typeof obj === 'object') && obj.constructor == Array);\r\nexport const is_String = (str) => ((typeof str === 'string') && str.constructor == String);\r\nexport const is_Function = (obj) => ((typeof obj === 'function') && obj.constructor == Function);\r\n\r\nexport const is_Empty = (val)=>{\r\n  if(!val) return true;\r\n  if(is_Array(val)){\r\n    return !val.length;\r\n  }else{\r\n    return !Object.keys(val).length;\r\n  }\r\n}\r\n\r\n/*\r\n * Delete the Item in an Array, returning the new Array.\r\n */\r\nexport var removeArrayItem = (arr, item) => {\r\n  if (arr.length) {\r\n    let index = arr.indexOf(item);\r\n    if (index > -1) {\r\n      return arr.splice(index, 1);\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n * Provide with a processor accept a list of stuff or single stuff\r\n * Give it the action to its inner iterator.\r\n * The original Stuff can not be an Array!\r\n */\r\nexport function arbitraryFree(input, func) {\r\n  if (input.forEach) {\r\n    return input.forEach(func);\r\n  } else {\r\n    return func(input, 0);\r\n  }\r\n}\r\n\r\nexport function storageAvailable(type) {\r\n  var storage;\r\n  try {\r\n    storage = window[type];\r\n    var x = '__storage_test__';\r\n    storage.setItem(x, x);\r\n    storage.removeArrayItem(x);\r\n    return true;\r\n  }\r\n  catch (e) {\r\n    return e instanceof DOMException && (\r\n      // everything except Firefox\r\n      e.code === 22 ||\r\n      // Firefox\r\n      e.code === 1014 ||\r\n      // test name field too, because code might not be present\r\n      // everything except Firefox\r\n      e.name === 'QuotaExceededError' ||\r\n      // Firefox\r\n      e.name === 'NS_ERROR_DOM_QUOTA_REACHED') &&\r\n      // acknowledge QuotaExceededError only if there's something already stored\r\n      (storage && storage.length !== 0);\r\n  }\r\n}\r\n\r\nexport const DEBUG = process.env.NODE_ENV !== 'production';\r\n\r\nexport const EnvAssociate = {\r\n  Light: false,\r\n};\r\n","/**\r\n * Status for Mutex\r\n */\r\n\r\nconst CREATED = 'created';\r\nconst MOUNTED = 'mounted';\r\nconst IDLE = 'idle';\r\nconst LOADING = 'loading';\r\nconst SAVING = 'saving';\r\nconst CLEARING = 'clearing';\r\n\r\n\r\nexport {\r\n  CREATED,\r\n  IDLE,\r\n  LOADING,\r\n  SAVING,\r\n  CLEARING,\r\n  MOUNTED,\r\n};\r\n","/**\r\n * The Laction JS(lactionQueue JS) entry file.\r\n * Light version.\r\n * Only includes the core build.\r\n * And it do not protect member variable safety.\r\n */\r\n\r\nimport { EnvAssociate } from './utils/util';\r\nimport { InitStore } from './core/store';\r\nimport { InitCore } from './core/lycabinet';\r\nimport { InitLazyDepartment } from './core/lazy-support';\r\nimport { InitMixin } from \"./core/mixin\";\r\n\r\n\r\n// set light on\r\nEnvAssociate.Light = true;\r\n/**\r\n * Using fake event system.\r\n * @param {*} Lycabinet \r\n */\r\nconst InitEventSystem = function(Lycabinet){\r\n  Lycabinet.prototype._setlog = new Function();\r\n  Lycabinet.prototype._once = new Function();\r\n  Lycabinet.prototype._trigger = new Function();\r\n  Lycabinet.prototype._off = new Function();\r\n  Lycabinet.prototype._on = new Function();\r\n}\r\n\r\n\r\nfunction Lycabinet(...options){\r\n  if (process.env.NODE_ENV !== 'production' && !(this instanceof Lycabinet) ) {\r\n    (global.warn || console.warn)('Lycabinet is a constructor and should be called with the `new` keyword');\r\n    return null;\r\n  }\r\n  this._init.apply(this, options);\r\n}\r\n\r\nInitStore(Lycabinet);\r\nInitEventSystem(Lycabinet);\r\nInitCore(Lycabinet);\r\nInitLazyDepartment(Lycabinet);\r\nInitMixin(Lycabinet);\r\n\r\n/**\r\n * Select Extends modules optional.\r\n */ \r\n// import { initImbedding } from './core/immbedding';\r\n// import { initAlias } from './extends/alias';\r\n// import { addFilter } from './extends/filter';\r\n// import { addObserver } from './extends/observer';\r\n\r\n// initImbedding(Lycabinet);\r\n// initAlias(Lycabinet);\r\n\r\n// addFilter(Lycabinet);\r\n// addObserver(Lycabinet);\r\n\r\nexport default Lycabinet;\r\n","/**\r\n * Given a private variable for every set storage.\r\n * Basement.\r\n */\r\n\r\nimport { is_Defined } from \"../utils/util\";\r\n\r\nexport function InitStore(Lycabinet){\r\n  const __cabinet = Object.create(null);\r\n  // var __cabinet = Object.create(null); // Replaceable.\r\n\r\n  Lycabinet.prototype.hasStore = function(){\r\n    return is_Defined(__cabinet[this.__root]);\r\n  }\r\n\r\n  /**\r\n   * Get the cabinet access.\r\n   * @returns {Plain Object} __cabinet ; The reference of the storage Object property.\r\n   * Each instance is shared by the root key.\r\n   */\r\n  Lycabinet.prototype.getStore = function(){\r\n    return __cabinet[this.__root];\r\n  }\r\n  \r\n  /**\r\n   * To initialize the __cabinet storage. \r\n   * @param {Plain Object} cabinet \r\n   */\r\n  Lycabinet.prototype.setStore = function(cabinet){\r\n    __cabinet[this.__root] = cabinet;\r\n  }\r\n}\r\n","/**\r\n * lycabinet.js\r\n * A high performance JSON Object storage helper.\r\n * 高性能的 JSON对象 小型数据存储辅助类\r\n * @createdTime 2021-03-28\r\n */\r\n\r\nimport * as _STATUS from '../utils/status.js';\r\nimport { deepAssign, arbitraryFree, is_Defined, is_PlainObject, DEBUG, is_Empty, arrayIndex } from '../utils/util';\r\n\r\n/**\r\n * Init core.\r\n * @param {*} root \r\n * @param {Object} options => {\r\n *   initStorage => Object, // 初始化值\r\n *   outerSave => Function, // 自定义保存方法，接收一个参数，为存储的数据对象\r\n *   outerLoad => Function, // 自定义装载方法，返回一个对象，将Assign给数据存储对象\r\n * }\r\n * 注意：以上网络请求的外部通信方法需要返回一个Promise对象.\r\n */\r\nexport function InitCore(Lycabinet){\r\n  \r\n  /**\r\n   * The configuration initialization.\r\n   * @param { String } root \r\n   * @param { Object } options \r\n   */\r\n  Lycabinet.prototype._init = function(root: string, options: Record<string, unknown> = {} ){\r\n\r\n    if(options.initStorage && !is_PlainObject(options.initStorage) ){\r\n      throw new Error(\"[Lycabinet]:The type of the provided option `initStorage` must be an Object!\");\r\n    }\r\n    if( !is_PlainObject(root)) \r\n      throw new Error(`[Lycabinet]: The param \"root\" should be an string, than type ${typeof root}!`);\r\n    this.__root = (root || 'lycabinet') + ''; // The key in storage. Must be a string.\r\n\r\n    // default options.\r\n    const defaultOptions = {\r\n      root: this.__root, // copy to options.\r\n      autoload: true, // 实例化后 自动调用 __init 方法实例化. (并且此时init中会自动调用 load 方法. 默认使用 Object.assign 浅合并，可手动调用传参深度合并.)\r\n      lazyPeriod : ~~(options.lazyPeriod as number) || 5000, // set the lazy period of lazySave methods.\r\n      saveMutex: true, // 存储互斥 仅在 idle 状态可进行保存操作. （暂时未防止loading完成前修改……）\r\n      autoLazy: true, // Call lazy save automaticly when the save is busy. \r\n      logEvent: false, // use this to log event globally from scratch\r\n      useSharedCabinet: true, // use global shared cabinet\r\n      shareCabinet: true, // share the cabinet for global\r\n      // local interfaces of storage\r\n      localInterface: {\r\n        database: window.localStorage,\r\n        getItem: \"getItem\", // method name, String\r\n        setItem: \"setItem\", // method name, String\r\n        removeItem: \"removeItem\", // method name, String\r\n      }, \r\n      \r\n      // Decide weather enable local cabinet when cloud is setted. Auto judge.\r\n      concurrence: !(options.outerLoad && options.outerSave && options.outerClear),\r\n      // cloud loads example options. The inner pointer `this` is pointed to `cabinet.options` if not set by arrow function.\r\n      outerLoad: ([root, cabinet], success, error)=>{\r\n        // data = load(root)\r\n        let data = {};\r\n        success(data);\r\n      },\r\n      outerSave: ([root, cabinet], success, error)=>{\r\n        // save(root, cabinet)\r\n        success();\r\n      },\r\n      outerClear: ([root, cabinet], success, error)=>{\r\n        // clear(root)\r\n        success();\r\n      },\r\n    };\r\n    this.options = deepAssign(defaultOptions, options);\r\n    this.__install(this.options);\r\n    \r\n    // root event console log\r\n    if(this.options.logEvent) this._setlog();\r\n\r\n    this.status = _STATUS.CREATED; // status token\r\n    this._trigger(\"created\");\r\n    // From now can have CURD manipulations.\r\n    if(this.options.autoload) this.__init(options.initStorage || Object.create(null) );\r\n  };\r\n\r\n  /**\r\n   * Initialize the cabinet storage before 'CURD' manipulation.\r\n   * If autoload is not setted, you should call this manually.\r\n   * Todo: add reduplicate __init check and warning.\r\n   */\r\n  Lycabinet.prototype.__init = function(cabinet = Object.create(null)){\r\n    // write protection backflow\r\n    const writeBackflow = function(){\r\n      if(is_Empty(this.__tempStorage)) return;\r\n      // backflow\r\n      deepAssign(this.__storage, this.__tempStorage);\r\n      this.__tempStorage = Object.create(null);\r\n      this._trigger(\"writeBackflow\");\r\n    }\r\n    this._on(\"loaded\", writeBackflow);\r\n    this._on(\"cleared\", writeBackflow);\r\n\r\n    // override the options by the already existed cabinet.\r\n    // this is global shared with all the instance in the page.\r\n    if(this.options.useSharedCabinet && this.hasStore()){\r\n      this._trigger(\"loadingFromCache\");\r\n      this.__storage = this.getStore();\r\n    }\r\n    else{\r\n      this.__storage = this.__storage || cabinet;\r\n      if(this.options.shareCabinet)\r\n        this.setStore(this.__storage);\r\n      // Auto load. Only when the cabinet in using is private.\r\n      if(this.options.autoload) this.load(false); // default using shallow assign.\r\n      else this.status = _STATUS.IDLE; // Amend the status error.\r\n    }\r\n\r\n    this.status = _STATUS.MOUNTED;\r\n    this._trigger(\"mounted\");\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Test the cabinet is busy or not.\r\n   */\r\n  Lycabinet.prototype.isVacant = function(){\r\n    return this.status===_STATUS.IDLE;\r\n  }\r\n\r\n  /**\r\n   * Set an item with key.\r\n   * Added write protection on stage loading and clearing.\r\n   * @param {*} key \r\n   * @param {*} value \r\n   */\r\n  Lycabinet.prototype.set = function(key, value){\r\n    const MutexStatus = [_STATUS.LOADING, _STATUS.CLEARING];\r\n    // add write protection.    \r\n    if(MutexStatus.indexOf(this.status) > -1){\r\n      this._trigger(\"writeLock\");\r\n      this.__tempStorage = this.__tempStorage || (this.__tempStorage = Object.create(null));\r\n      this.__tempStorage[key] = value;\r\n      return this;\r\n    }\r\n\r\n    this.__storage[key] = value;\r\n    this._trigger('setItem', key, value);\r\n    return this;\r\n  };\r\n\r\n  /**\r\n   * Get the value of an item by key.\r\n   * Please don't read from loading and clearing stream.\r\n   * @param {*} key \r\n   */\r\n  Lycabinet.prototype.get = function(key){\r\n    let backValue = this.__storage[key];\r\n    this._trigger('getItem', key, backValue);\r\n    return backValue;\r\n  }\r\n\r\n  /**\r\n   * Delete an item by key.\r\n   */ \r\n  Lycabinet.prototype.remove = function(keys){\r\n    let removed = false;\r\n    arbitraryFree(keys, (k)=>{\r\n      // Though it isn't disappeared immediately, But after JSON parse and stringify manipulations this will be cleared.\r\n      if(this.__storage.hasOwnProperty(k)){\r\n        this.set(k, void 0);\r\n        removed = true\r\n      }\r\n    }); \r\n    this._trigger('removeItem', keys, removed);\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Delete the cabinet directly.\r\n   * But the data may still exist in memory.  \r\n   * @param {Boolean} onCloud \r\n   * @param {Boolean} concurrent Override the default options in `this.options.concurrence`\r\n   */\r\n  Lycabinet.prototype.clear = function(onCloud: boolean|null = null, concurrent: boolean|null = null){\r\n    // merge default options.\r\n    concurrent = is_Defined(concurrent)? concurrent: this.options.concurrence;\r\n    onCloud = is_Defined(onCloud)? onCloud: !!this.options.outerClear;\r\n    this.status = _STATUS.LOADING;\r\n    this._trigger('beforeClear');\r\n    \r\n    // Local clear\r\n    let localClear = ()=>{\r\n      const IgnoreLocal = onCloud && !concurrent;\r\n      this._trigger('beforeLocalClear', IgnoreLocal); // give an status token before invoke.\r\n\r\n      if(IgnoreLocal){\r\n        DEBUG && console.log(\"[Lycabinet]: The local clear action is ignored by options: concurrence=false.\");\r\n        return this;\r\n      }\r\n      const localApi = this.options.localInterface;\r\n      localApi.database[localApi.removeItem]( this.__root );\r\n      // trigger hook event after call local database to clear the Item.\r\n      this._trigger('localCleared', this.__root); // Give the param of the remove target. \r\n    }\r\n\r\n    // Cloud clear\r\n    const pack = [this.__root, this.__storage];\r\n    const onSuccess = ()=>{\r\n      this.status = _STATUS.IDLE;\r\n      this._trigger('cleared', onCloud, concurrent);\r\n    }\r\n    const onError = (msg, reason='')=>{\r\n      this._trigger(\"error\", \"clear\", \"cloudClearings\", reason);\r\n      this.status = _STATUS.IDLE;\r\n      this._trigger('cleared', onCloud, concurrent);\r\n      console.error(`[Lycabinet]: Failed to Clear the cabinet \"${this.__root}\" on cloud. ${msg}`);\r\n    }\r\n\r\n    // handle this async or asyn easily.\r\n    try{\r\n      localClear();\r\n      if(onCloud) \r\n        this.options.outerClear(pack, onSuccess, onError);\r\n      else {\r\n        this.status = _STATUS.IDLE;\r\n        this._trigger('cleared', onCloud, concurrent);\r\n      }\r\n    } catch(e){\r\n      onError(e, \"unknown\");\r\n    }\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Load the cabinet on initialization.\r\n   * The local load is faster than cloud.\r\n   * @param { Boolean } onCloud \r\n   * @param { Boolean } concurrent Override the default options in `this.options.concurrence`\r\n   * @param { Boolean } deepMerge Using deepAssign instead of Object.assign to merge the data from local and cloud.\r\n   */\r\n  Lycabinet.prototype.load = function(deepMerge = false, onCloud: boolean|null = null, concurrent: boolean|null = null){\r\n    // merge default options.\r\n    concurrent = is_Defined(concurrent)? concurrent: this.options.concurrence;\r\n    onCloud = is_Defined(onCloud)? onCloud: !!this.options.outerLoad;\r\n    this.status = _STATUS.LOADING;\r\n    this._trigger(\"beforeLoad\");\r\n\r\n    // Local load \r\n    let localLoad = ()=>{\r\n      let localTemp = null;\r\n      const IgnoreLocal = onCloud && !concurrent;\r\n      this._trigger('beforeLocalLoad', IgnoreLocal); // give an status token before invoke.\r\n\r\n      if(IgnoreLocal){\r\n        DEBUG && console.log(\"[Lycabinet]: The local load action is ignored by options: concurrence=false.\");\r\n        return this;\r\n      }\r\n      const localApi = this.options.localInterface;\r\n      \r\n      let initialData = localApi.database[localApi.getItem]( this.__root );\r\n      // trigger hook event after call local database to parse the value. Should have a return value in event. (data)=>{ return handle(data); }\r\n      initialData = this._trigger('localLoaded', initialData); // Only take effect on the last element.\r\n\r\n      localTemp = JSON.parse( initialData );\r\n      if(deepMerge)\r\n        deepAssign(this.__storage, localTemp);\r\n      else\r\n        Object.assign(this.__storage, localTemp);\r\n    };\r\n\r\n    // Cloud load\r\n    const pack = [this.__root, this.__storage];\r\n    const onSuccess = (data)=>{\r\n      if(!is_Defined(data) || !is_PlainObject(data))\r\n        throw new Error(`[Lycabinet]: Load cabinet with empty 'data' which type is ${typeof data}`);\r\n        \r\n      if(deepMerge)\r\n        deepAssign(this.__storage, data);\r\n      else \r\n      // shallow assign makes cloud weight heavier.\r\n        Object.assign(this.__storage, data);\r\n      this.status = _STATUS.IDLE;\r\n      this._trigger('loaded', onCloud, concurrent);\r\n    }\r\n    const onError = (msg, reason='')=>{\r\n      this._trigger(\"error\", \"load\", \"cloudLoadings\", reason);\r\n      this.status = _STATUS.IDLE;\r\n      this._trigger('loaded', onCloud, concurrent);\r\n      console.error(`[Lycabinet]: Failed to Load the cabinet \"${this.__root}\" on cloud. ${msg}`);\r\n    }\r\n\r\n    // handle this async or asyn easily.\r\n    try{\r\n      localLoad();\r\n      if(onCloud) \r\n        this.options.outerLoad(pack, onSuccess, onError);\r\n      else {\r\n        this.status = _STATUS.IDLE;\r\n        this._trigger('loaded', onCloud, concurrent);\r\n      }\r\n    } catch(e){\r\n      onError(e, \"unknown\");\r\n    }\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Save the cabinet to database or cloud.\r\n   * @param {*} onCloud \r\n   * @param {Boolean} concurrent Override the default options in `this.options.concurrence`\r\n   */\r\n  Lycabinet.prototype.save = function(onCloud: boolean|null = null, concurrent: boolean|null = null){\r\n    // check the status for mutex protection\r\n    let check = this.options.saveMutex && !this.isVacant();\r\n    this._trigger(\"beforeSave\", check);\r\n    if( check ){\r\n      DEBUG && console.log(`[Lycabinet]: The 'save' manipulation is deserted for busy. Current Status: ${this.status} \\nSet 'saveMutex' false to disable it.`);\r\n      this._trigger(\"busy\");\r\n      this.options.autoLazy && this.lazySave(onCloud, concurrent);\r\n      return this;\r\n    }\r\n    \r\n    // merge default options.\r\n    onCloud = is_Defined(onCloud)? onCloud: !!this.options.outerSave;\r\n    concurrent = is_Defined(concurrent)? concurrent: this.options.concurrence;\r\n    this.status = _STATUS.SAVING;\r\n\r\n    // Local save \r\n    let localSave = ()=>{\r\n      const IgnoreLocal = onCloud && !concurrent;\r\n      this._trigger('beforeLocalSave', IgnoreLocal); // give an status token before invoke.\r\n\r\n      if(IgnoreLocal){\r\n        DEBUG && console.log(\"[Lycabinet]: The local save action is ignored by options: concurrence=false.\");\r\n        return this;\r\n      }\r\n      const localApi = this.options.localInterface;\r\n      // trigger hook event beforeLocalSave. Should have a return value in event. (data)=>{ return handle(data); }\r\n      let finalData = JSON.stringify(this.__storage );\r\n      // trigger hook event after call local database to save the value. Should return a String value in event.\r\n      finalData = this._trigger('localSaved', finalData); // Only take effect on the last element.\r\n\r\n      localApi.database[localApi.setItem](this.__root, finalData);\r\n    };\r\n    \r\n\r\n    // Cloud save\r\n    const pack = [this.__root, this.__storage];\r\n    const onSuccess = ()=>{\r\n      this.status = _STATUS.IDLE;\r\n      this._trigger('saved', onCloud, concurrent);\r\n    }\r\n    const onError = (msg, reason=\"cloudSavings\")=>{\r\n      this._trigger(\"error\", \"save\", reason);\r\n      this.status = _STATUS.IDLE;\r\n      this._trigger('saved', onCloud, concurrent);\r\n      console.error(`[Lycabinet]: Failed to Save the cabinet \"${this.__root}\" on cloud. ${msg}`);\r\n    }\r\n\r\n    // handle this async or asyn easily.\r\n    try{\r\n      localSave();\r\n      if(onCloud) \r\n        this.options.outerSave(pack, onSuccess, onError);\r\n      else {\r\n        this.status = _STATUS.IDLE;\r\n        this._trigger('saved', onCloud, concurrent);\r\n      }\r\n    } catch(e){\r\n      onError(e, 'unknown')\r\n    }\r\n    return this;\r\n  }\r\n  \r\n  /**\r\n   * Map methods support.\r\n   * Iterate the first hierarchy with callback.\r\n   * @param {Function: (item, index)=>any }} callback with two params\r\n   */\r\n  Lycabinet.prototype.forEach = function(callback){\r\n    let item, index = 0;\r\n    for(let key in this.__storage){\r\n      item = this.__storage[key];\r\n      callback(item, index++); // only two params.\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Foreach methods support.\r\n   * Iterate the first hierarchy with callback.\r\n   * @param {Function: (item, index)=>any }} callback  with two params\r\n   */\r\n  Lycabinet.prototype.map = function(callback){\r\n    let item, index = 0;\r\n    for(let key in this.__storage){\r\n      item = this.__storage[key];\r\n      this.__storage[key] = callback(item, index++); // only two params.\r\n    }\r\n  }\r\n}\r\n","/**\r\n * Lazy methods support.\r\n * @param {*} Lycabinet \r\n */\r\nexport function InitLazyDepartment(Lycabinet){\r\n  \r\n  /**\r\n   * Add lazySave support.\r\n   * The params is the same to save methods.\r\n   */\r\n  Lycabinet.prototype.lazySave = (function(){\r\n    var lastTime = 0;\r\n    return function(...params){\r\n      var nowTime = new Date().getTime();\r\n      // The gap is not so accurate but enough.\r\n      let judge = nowTime - lastTime > 5000; //this.options.lazyPeriod;\r\n      this._trigger(\"lazySave\", judge);\r\n      if (judge) {\r\n        lastTime = nowTime; // first!\r\n        // Use default settings\r\n        console.log(\"Lazy executed!\", nowTime, lastTime, judge)\r\n        this.save(...params);\r\n      }\r\n      return this;\r\n    }\r\n  })();\r\n\r\n  /**\r\n   * Just calling lazySave after save called.\r\n   * @param {*} key \r\n   * @param {*} value \r\n   * @param {...any} params parameters to lazySave (). \r\n   */\r\n  Lycabinet.prototype.lazySet = function(key, value, ...params){\r\n    this.set(key, value).lazySave(...params);\r\n    return this;\r\n  }\r\n}","/**\r\n * Lycabinet Mixin.\r\n */\r\nexport function InitMixin(Lycabinet){\r\n  Lycabinet.prototype._mixins = []; // 实例共享属性\r\n\r\n  Lycabinet.mixin = function (mixinFunc) {\r\n    Lycabinet.prototype._mixins.push(mixinFunc);\r\n    return this;\r\n  };\r\n\r\n  Lycabinet.prototype.__install = function(...options){\r\n    options.unshift(this);\r\n    Lycabinet.prototype._mixins.forEach(func => {\r\n      func.apply(func, options);\r\n    });\r\n  };\r\n}"],"names":["root","factory","exports","module","define","amd","self","__webpack_require__","definition","key","o","Object","defineProperty","enumerable","get","obj","prop","prototype","hasOwnProperty","call","invokeQueue","window","addEventListener","eve","forEach","func","deepAssign","objs","merged","reduce","target","source","item","is_PlainObject","is_Defined","v","toString","IDLE","LOADING","Lycabinet","options","this","_init","apply","__cabinet","create","hasStore","__root","getStore","setStore","cabinet","InitStore","_setlog","Function","_once","_trigger","_off","_on","InitEventSystem","initStorage","Error","defaultOptions","autoload","lazyPeriod","saveMutex","autoLazy","logEvent","useSharedCabinet","shareCabinet","localInterface","database","localStorage","getItem","setItem","removeItem","concurrence","outerLoad","outerSave","outerClear","success","error","__install","status","__init","writeBackflow","val","__tempStorage","Array","isArray","constructor","length","keys","__storage","load","isVacant","set","value","indexOf","backValue","remove","removed","input","k","clear","onCloud","concurrent","localClear","IgnoreLocal","localApi","pack","onSuccess","onError","msg","reason","console","e","deepMerge","localLoad","localTemp","initialData","JSON","parse","assign","data","save","check","lazySave","localSave","finalData","stringify","callback","index","map","InitCore","lastTime","params","nowTime","Date","getTime","judge","log","lazySet","InitLazyDepartment","_mixins","mixin","mixinFunc","push","unshift","InitMixin"],"sourceRoot":""}