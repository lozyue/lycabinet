{"version":3,"file":"lycabinet.light.esm.min.js","mappings":"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","sources":["webpack://Lycabinet/webpack/bootstrap","webpack://Lycabinet/webpack/runtime/define property getters","webpack://Lycabinet/webpack/runtime/hasOwnProperty shorthand","webpack://Lycabinet/./src/utils/util.ts","webpack://Lycabinet/./src/light.ts","webpack://Lycabinet/./src/core/store.ts","webpack://Lycabinet/./src/core/lycabinet.ts","webpack://Lycabinet/./src/utils/status.ts","webpack://Lycabinet/./src/core/lazy-support.ts","webpack://Lycabinet/./src/core/mixin.ts","webpack://Lycabinet/./src/extends/alias.ts"],"sourcesContent":["// The require scope\nvar __webpack_require__ = {};\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","/**\r\n * Utils.js.\r\n * By lozyue.\r\n */\r\n\r\n/**\r\n * Get the item in an array with index. Support negative index.\r\n * @param  {...any} objs \r\n */\r\nexport const arrayIndex = function (arr, index) {\r\n  index = (arr.length + index) % arr.length;\r\n  if (arr[index] === undefined) {\r\n    DEBUG&& console.error(`The index ${index} in array ${arr.toString()} is overflowed!`);\r\n  }\r\n  return arr[index];\r\n}\r\n\r\n/**\r\n * Get the target curve path value of the source Object.\r\n * The curve path is a sequenced array\r\n * @param source \r\n * @param objPathes \r\n */\r\nexport function curveGet(source: Object, objPathes: string[]){\r\n  let interim = source, item = '';\r\n  for(let index=0; index<objPathes.length; index++){\r\n    item = objPathes[index];\r\n    interim = interim && interim[item]\r\n    if(interim === void 0 ){\r\n      return void 0;\r\n    };\r\n  }\r\n  return interim;\r\n}\r\n\r\n/**\r\n * Set the consistent even curve path of the source Object \r\n * The curve path is a sequenced array // dot split strings.\r\n * @param source \r\n * @param objPathes \r\n * @param {unknown|Function} value The value assign for the curve object target. Support callback that if target value is a function you should set it in call back.\r\n * @returns { number|true } The number indicator the failed position of the conflict path.\r\n */\r\n export function curveSet(source: Object, objPathes: string[], value: ((target: Object, name: string)=>any)| unknown= null){\r\n  let interim = source, item = '';\r\n  // not the last one.\r\n  let index=0;\r\n  for(; index<objPathes.length-1; index++){\r\n    item = objPathes[index];\r\n    if(is_Defined(interim[item]) ){\r\n      if(is_Object(interim[item])){\r\n        interim = interim[item];\r\n      } else {\r\n        // Unexpected non-object value.\r\n        return index;\r\n      }\r\n    } else \r\n      interim = interim[item] = {};\r\n  };\r\n  // the last\r\n  item = objPathes[index];\r\n  // assign the value.\r\n  if(is_Function(value))\r\n    (value as Function)(interim, item);\r\n  else\r\n    interim[item] = value;\r\n  return true;\r\n}\r\n\r\n/**\r\n * Centralized management.\r\n * Add a listener to window storage event.\r\n * @param { Function } invoke Target invoke function or handle. \r\n * @param { Boolean } remove wheather the action is to remove added storage listener.\r\n */\r\nexport const addStoreListener = (()=>{\r\n  const invokeQueue: Function[]= [];\r\n  window.addEventListener(\"storage\", (eve)=>{\r\n    invokeQueue.forEach(func=>{\r\n      func(eve);\r\n    });\r\n  }, false); // default bubble.\r\n\r\n  return (invoke, remove = false)=>{\r\n    if(remove) \r\n      removeArrayItem(invokeQueue, invoke);\r\n    else invokeQueue.push(invoke);\r\n  }\r\n})();\r\n\r\n/**\r\n * Deep Object.assign source to target.\r\n * @param { null|Object, Object... }...objs\r\n */\r\nexport const deepAssign = function (...objs) {\r\n  let merged;\r\n  objs.reduce((target, source) => {\r\n    for (let item in source) {\r\n      if (!(target[item] && is_PlainObject(target[item])) ) {\r\n        target[item] = source[item];\r\n      } else {\r\n        deepAssign(target[item], source[item]);\r\n      }\r\n    }\r\n    merged = target;\r\n    return target;\r\n  }, objs[0]); // The third param is to set default value.\r\n  return merged;\r\n}\r\n\r\n/**\r\n * Deep Object.assign source to target.\r\n * @param target\r\n * @param source\r\n * @param condition Receive the to contacted source and target value and returns the custom result.\r\n */\r\nexport const deepConditionalAssign = function (source, target, condition:null|Function=null ) {\r\n  for (let item in target) {\r\n    if (!(source[item] && is_PlainObject(source[item])) ) {\r\n      // The source Item won't be PlainObject or FalseValue.\r\n      if(!condition)\r\n        source[item] = target[item];\r\n      else\r\n        source[item] = condition(source[item], target[item]);\r\n    } else {\r\n      deepConditionalAssign(source[item], target[item]);\r\n    }\r\n  }\r\n  return source;\r\n}\r\n\r\n/**\r\n * Just assign the item in supplement which not defined in target.\r\n * If you don't want to override the value of origin Object, supplement is the high performance choice.\r\n * Not deep mode.\r\n * @param {*} target \r\n * @param {*} supplement \r\n */\r\nexport function objectSupplement(target, supplement) {\r\n  let current = null;\r\n  for (let item in supplement) {\r\n    current = target[item];\r\n    if (is_Defined(current))\r\n      continue;\r\n    target[item] = supplement[item];\r\n  }\r\n  return target;\r\n}\r\n\r\n/**\r\n * Just assign the item in supplement which not defined in target.\r\n * If you don't want to override the value of origin Object, supplement is the high performance choice.\r\n * Deep mode by iterate each inner Object.\r\n * @param {*} target \r\n * @param {*} supplement \r\n */\r\nexport function deepSupplement<R extends Object, T extends Object> (target: R|null, supplement: T) {\r\n  if(!target) return supplement;\r\n  let current: unknown = null;\r\n  for (let item in supplement) {\r\n    current = (target as unknown as T)[item];\r\n    if (is_Defined(current)) {\r\n      if (!is_PlainObject(current as Object)) continue;\r\n      deepSupplement(current as Object, supplement[item]); // The `current` is a reference which could be assigned.\r\n    }\r\n    else\r\n      // current = supplement[item];\r\n      (target as unknown as T)[item] = supplement[item];\r\n  }\r\n  return target as (R & T);\r\n}\r\n\r\n\r\n/**\r\n * Simple deepClone with optional Function clone\r\n */\r\nexport function deepClone(val, substituteObj = Object.create(null), cloneFunc = true) {\r\n  if (is_PlainObject(val)) {\r\n    var res = substituteObj;\r\n    for (var key in val) {\r\n      res[key] = deepClone(val[key]);\r\n    }\r\n    return res;\r\n  } else if (is_Array(val)) {\r\n    return val.slice()\r\n  } else if (cloneFunc && is_Function(val)) {\r\n    return Object.create(val.prototype).constructor;\r\n  } else {\r\n    return val;\r\n  }\r\n}\r\n\r\nexport function iterateObject(source: Object, iterate: Function){\r\n  iterate(source);\r\n  for(let item in source){\r\n    if( is_PlainObject(source[item]) )\r\n      iterate(source, iterate);\r\n  }\r\n}\r\n\r\nexport const is_Defined = (v: unknown):Boolean => (v !== undefined && v !== null);\r\nexport const is_Object = (obj: unknown):Boolean => (obj instanceof Object || typeof obj === \"object\");\r\nexport const is_PlainObject = (obj: unknown):Boolean => (Object.prototype.toString.call(obj) === '[object Object]');\r\nexport const is_Array = (obj: unknown):Boolean => (Array.isArray && Array.isArray(obj) || obj instanceof Array || (typeof obj === 'object') && Object.prototype.toString.call(obj).slice(-6,-1)=== 'Array' );\r\nexport const is_String = (str: Object):Boolean => ((typeof str === 'string') && str.constructor == String);\r\nexport const is_Function = (obj: unknown):Boolean => (obj instanceof Function);\r\n\r\nexport const is_Empty = (val: unknown)=>{\r\n  if(!val) return true;\r\n  if(is_Array(val)){\r\n    return !(val as Array<unknown>).length;\r\n  }else{\r\n    return !Object.keys((val) as Object).length;\r\n  }\r\n}\r\n\r\n/*\r\n * Delete the Item in an Array, returning the new Array.\r\n */\r\nexport var removeArrayItem = (arr, item) => {\r\n  if (arr.length) {\r\n    let index = arr.indexOf(item);\r\n    if (index > -1) {\r\n      return arr.splice(index, 1);\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n * Provide with a processor accept a list of stuff or single stuff\r\n * Give it the action to its inner iterator.\r\n * The original Stuff can not be an Array!\r\n */\r\nexport function arbitraryFree(input, func) {\r\n  if (input.forEach) {\r\n    return input.forEach(func);\r\n  } else {\r\n    return func(input, 0);\r\n  }\r\n}\r\n\r\nexport function storageAvailable(type) {\r\n  var storage;\r\n  try {\r\n    storage = window[type];\r\n    var x = '__storage_test__';\r\n    storage.setItem(x, x);\r\n    storage.removeArrayItem(x);\r\n    return true;\r\n  }\r\n  catch (e) {\r\n    return e instanceof DOMException && (\r\n      // everything except Firefox\r\n      e.code === 22 ||\r\n      // Firefox\r\n      e.code === 1014 ||\r\n      // test name field too, because code might not be present\r\n      // everything except Firefox\r\n      e.name === 'QuotaExceededError' ||\r\n      // Firefox\r\n      e.name === 'NS_ERROR_DOM_QUOTA_REACHED') &&\r\n      // acknowledge QuotaExceededError only if there's something already stored\r\n      (storage && storage.length !== 0);\r\n  }\r\n}\r\n\r\nexport const LogToken = \"[Lycabinet]: \";\r\n\r\nexport const DEBUG = process.env.NODE_ENV !== 'production';\r\n\r\nexport const EnvAssociate = {\r\n  Light: false, // light mode.\r\n};\r\n","/**\r\n * The Laction JS(lactionQueue JS) entry file.\r\n * Slight version.\r\n * Only includes the core build (No event system).\r\n * For smaller build bundle.\r\n */\r\n\r\nimport { EnvAssociate } from './utils/util';\r\nimport { InitStore } from './core/store';\r\nimport { InitCore } from './core/lycabinet';\r\nimport { InitLazyDepartment } from './core/lazy-support';\r\nimport { InitMixin } from \"./core/mixin\";\r\n\r\n\r\n// set light on\r\nEnvAssociate.Light = true;\r\n/**\r\n * Using fake event system.\r\n * @param {*} Lycabinet \r\n */\r\nconst InitEventSystem = function(Lycabinet){\r\n  const Protos = Lycabinet.prototype;\r\n  const NoopFunc = Function();\r\n\r\n  const MethodList = [\"isHappened\",\"setlog\",\"ready\",\"next\",\"count\",\"trigger\",\"off\",\"on\"];\r\n  MethodList.forEach(mtd => {\r\n    Protos['_'+mtd] = NoopFunc;\r\n  });\r\n}\r\n\r\n\r\nfunction Lycabinet(...options){\r\n  if (process.env.NODE_ENV !== 'production' && !(this instanceof Lycabinet) ) {\r\n    (global.warn || console.warn)('Lycabinet is a constructor and should be called with the `new` keyword');\r\n    return null;\r\n  }\r\n  this.__init.apply(this, options);\r\n}\r\n\r\nInitStore(Lycabinet);\r\nInitEventSystem(Lycabinet);\r\nInitCore(Lycabinet);\r\nInitLazyDepartment(Lycabinet);\r\nInitMixin(Lycabinet);\r\n\r\n/**\r\n * Manually select the optional Extends modules.\r\n */ \r\n// import { initImbedding } from './core/immbedding';\r\n// initImbedding(Lycabinet);\r\n\r\n// import { addFilter } from './extends/filter';\r\n// addFilter(Lycabinet);\r\n\r\n// import { addObserver } from './extends/observer';\r\n// addObserver(Lycabinet);\r\n\r\n// import { addCheck } from './extends/check';\r\n// addCheck(Lycabinet);\r\n\r\n// import { addZip } from './extends/zip';\r\n// addZip(Lycabinet);\r\n\r\nimport { initAlias } from './extends/alias';\r\ninitAlias(Lycabinet);\r\n\r\n\r\nexport default Lycabinet;\r\n","/**\r\n * Given a private cabinet for every set storage.\r\n * Cabinet Basement.\r\n */\r\n\r\nimport { DEBUG, is_Defined, is_PlainObject } from \"../utils/util\";\r\n\r\nexport function InitStore(Lycabinet){\r\n  const __cabinet = Object.create(null);\r\n  const __insTable = Object.create(null);\r\n  DEBUG && (window[\"__cabinet\"] = __cabinet);\r\n  const Proto = Lycabinet.prototype;\r\n\r\n  /**\r\n   * Get the exact cabinet of current instance.\r\n   */\r\n  Proto.getCabinet = function(){\r\n    return this.__storage;\r\n  }\r\n\r\n  /**\r\n   * Check cache consistent.\r\n   * Conclude whether the current cabinet is consistent with the inner cache.\r\n   * @returns { Boolean }\r\n   */\r\n  Proto.isIdentical = function(){\r\n    return this.__storage === __cabinet[this.__root];\r\n  }\r\n\r\n  Proto.hasStore = function(){\r\n    return is_Defined(__cabinet[this.__root]) && is_PlainObject(__cabinet[this.__root]);\r\n  }\r\n\r\n  /**\r\n   * Get the cached cabinet access.\r\n   * @returns {Plain Object} __cabinet ; The reference of the storage Object property been cached.\r\n   * Each instance is shared by the root key.\r\n   */\r\n  Proto.getStore = function(){\r\n    return __cabinet[this.__root];\r\n  }\r\n  \r\n  /**\r\n   * To initialize the cabinet cache. \r\n   * @param {Plain Object} cabinet \r\n   */\r\n  Proto.setStore = function(cabinet){\r\n    __cabinet[this.__root] = cabinet;\r\n  }\r\n\r\n  /**\r\n   * To clear the inner cache of cabinet.\r\n   * Defaultly prevent sharing elimination.\r\n   */\r\n  Proto.removeStore = function(){\r\n    if(this.options.useSharedCabinet \r\n      || !this.options.shareCabinet \r\n      || !this.isIdentical()\r\n      || __insTable[this.__root].size<=0\r\n    ) return false;\r\n    __cabinet[this.__root] = void 0;\r\n    return true;\r\n  }\r\n\r\n  Lycabinet.$removeStore = function(root: string){\r\n    __cabinet[root] = void 0;\r\n  }\r\n\r\n  DEBUG && (Lycabinet.$getStore = function(root: string){\r\n    return __cabinet[root];\r\n  });\r\n\r\n  Lycabinet.mixin((cabinetIns)=>{\r\n    cabinetIns._on(\"created\", ()=>{\r\n      if(!__insTable[cabinetIns.__root])\r\n        __insTable[cabinetIns.__root] = new Set();\r\n      __insTable[cabinetIns.__root].add(cabinetIns);\r\n    });\r\n    \r\n    cabinetIns._on(\"destoryed\", ()=>{\r\n      __insTable[cabinetIns.__root].delete(cabinetIns);\r\n      if(__insTable[cabinetIns.__root].size<=0)\r\n        __insTable[cabinetIns.__root] = void 0;\r\n    });\r\n  });\r\n}\r\n","/**\r\n * lycabinet.js\r\n * A slight JSON Type Object storage helper with good performance.\r\n * 一个适用于JSON对象数据存储的轻量辅助类。\r\n * @author Lozyue\r\n * @createdTime 2021-03-28\r\n */\r\n\r\nimport { ConstructOptions, AccessOptions, SubSet } from '@/typings/lycabinet';\r\nimport * as _STATUS from '@/utils/status';\r\nimport { \r\n  deepAssign, arbitraryFree, curveGet, curveSet,\r\n  is_Defined, is_PlainObject, is_Empty, is_String,\r\n  LogToken, DEBUG, deepConditionalAssign, \r\n} from '@/utils/util';\r\n\r\nexport function InitCore(Lycabinet){\r\n  // Constructor Options\r\n  Lycabinet.DEBUG = true;\r\n  Lycabinet.SeparateLog = false;\r\n\r\n  const Proto = Lycabinet.prototype;\r\n  /**\r\n   * The configuration initialization.\r\n   * @param { String } root \r\n   * @param { Object } options \r\n   */\r\n  Proto.__init = function(root: string, options: Partial<ConstructOptions> = {} ){\r\n\r\n    if(options.initStorage && !is_PlainObject(options.initStorage) ){\r\n      throw new Error(`${LogToken}The type of the provided option \"initStorage\" must be an Object!`);\r\n    }\r\n    if( !is_String(root)) \r\n      throw new Error(`${LogToken}The param \"root\" should be an string, than type ${typeof root}!`);\r\n    this.__root = (root || 'lycabinet') + ''; // The key in storage. Must be a string.\r\n\r\n    // default options.\r\n    const defaultOptions = {\r\n      root: this.__root,\r\n      autoload: true,\r\n      lazyPeriod : ~~(options.lazyPeriod as number) || 5000, // set the lazy period of lazySave methods.\r\n      saveMutex: true,\r\n      autoLazy: true, // Call lazy save automaticly when the save is busy. \r\n      logEvent: false, // use this to log event globally from scratch\r\n      useSharedCabinet: true, // use global shared cabinet\r\n      shareCabinet: true, // share the cabinet for global\r\n      // Weather use deepAssign to contact when load from outer data.\r\n      deepMerge: false, \r\n      customMerge: null, // Applying just on loading.\r\n      // local interfaces of storage\r\n      localInterface: {\r\n        database: window.localStorage,\r\n        getItem: \"getItem\",\r\n        setItem: \"setItem\",\r\n        removeItem: \"removeItem\",\r\n      }, \r\n      concurrent: !!(options.outerLoad || options.outerSave || options.outerClear),\r\n      outerLoad: null,\r\n      outerSave: null,\r\n      outerClear: null,\r\n    };\r\n    this.options = deepAssign(defaultOptions, options);\r\n    // Make the privilege.\r\n    this.__install(defaultOptions);\r\n    \r\n    // root event console log\r\n    if(defaultOptions.logEvent) this._setlog();\r\n\r\n    this.status = _STATUS.CREATED;\r\n    this._trigger(\"created\");\r\n    \r\n    if(defaultOptions.autoload) this._init(options.initStorage || Object.create(null) );\r\n  };\r\n\r\n  /**\r\n   * Initialize the cabinet storage before 'CURD' manipulation.\r\n   * If autoload is not setted, you should call this manually.\r\n   */\r\n  Proto._init = function(cabinet:null|Object = null){\r\n    const options = this.options;\r\n    cabinet = (cabinet || options.initStorage || Object.create(null)) as Object;\r\n\r\n    // write protection backflow\r\n    const writeBackflow = function(){\r\n      if(is_Empty(this.__tempStorage)) return;\r\n      // backflow\r\n      deepAssign(this.__storage, this.__tempStorage);\r\n      this.__tempStorage = Object.create(null);\r\n      this._trigger(\"writeBackflow\");\r\n    }\r\n    this._on(\"loaded\", writeBackflow);\r\n    this._on(\"cleared\", writeBackflow);\r\n\r\n    // override the options by the already existed cabinet.\r\n    // this is global shared with all the instance in the page.\r\n    const isLoadFromCache = options.useSharedCabinet && this.hasStore();\r\n    if(isLoadFromCache){\r\n      this.__storage = this.getStore();\r\n      // Sync status.\r\n      if(options.deepMerge){\r\n        deepConditionalAssign(cabinet, this.__storage, options.customMerge);\r\n      }else\r\n        Object.assign(cabinet, this.__storage);\r\n      this._trigger(\"loadFromCache\", this.__storage);\r\n    }\r\n    else{\r\n      this.__storage = this.__storage || cabinet;\r\n      if(options.shareCabinet)\r\n        this.setStore(this.__storage);\r\n    }\r\n\r\n    this.status = _STATUS.MOUNTED;\r\n    this._trigger(\"mounted\"); // Interior cabinet access is attainable.\r\n\r\n    if(!isLoadFromCache){\r\n      // Auto load. Only when the cabinet is in private using.\r\n      if(options.autoload) this.load(); // default using shallow assign.\r\n      else this.status = _STATUS.IDLE; // Amend the status.\r\n    } else {\r\n      this.status = _STATUS.IDLE; // Amend the status.\r\n    }\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Test the cabinet is busy or not.\r\n   */\r\n  Proto.isVacant = function(){\r\n    return this.status===_STATUS.IDLE;\r\n  }\r\n\r\n  /**\r\n   * Set an item with key.\r\n   * Added write protection on stage of loading and clearing.\r\n   * @param {*} keys \r\n   * @param {*} value \r\n   */\r\n  Proto.set = function(keys, value){\r\n    const MutexStatus = [_STATUS.LOADING, _STATUS.CLEARING];\r\n    // add write protection.    \r\n    if(MutexStatus.indexOf(this.status) > -1){\r\n      this._trigger(\"writeLock\");\r\n      this.__tempStorage = this.__tempStorage || (this.__tempStorage = Object.create(null));\r\n      curveSet(this.__tempStorage, keys.split('.'), value);\r\n      return this;\r\n    }\r\n\r\n    curveSet(this.__storage, keys.split('.'), value);\r\n    this._trigger('setItem', keys, value);\r\n    return this;\r\n  };\r\n\r\n  /**\r\n   * Get the value of an item by key.\r\n   * Please don't read from loading and clearing stream.\r\n   * @param {*} keys support dot-split obj pathes\r\n   */\r\n  Proto.get = function(keys){\r\n    let backValue = curveGet(this.__storage, keys.split('.'));\r\n    this._trigger('getItem', keys, backValue);\r\n    return backValue;\r\n  }\r\n\r\n  /**\r\n   * Delete an item by key.\r\n   */ \r\n  Proto.remove = function(keys: string|string[]){\r\n    let removed = false;\r\n    arbitraryFree(keys, (k)=>{\r\n      // Though it isn't disappeared immediately, But after JSON parse and stringify manipulations this will be cleared.\r\n      if(this.__storage.hasOwnProperty(k)){\r\n        this.set(k, void 0);\r\n        removed = true;\r\n      }\r\n    });\r\n    removed && this._trigger('removeItem', keys, removed);\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Delete the cabinet directly.\r\n   * But the data may still exist in memory(RAM).  \r\n   * @param {Boolean} onCloud \r\n   * @param {Boolean} concurrent Override the default options in `this.options.concurrent`\r\n   */\r\n  Proto.clear = function(option: SubSet<AccessOptions, \"deepMerge\"> & { reset?: boolean } = {}){\r\n    // merge default options.\r\n    const concurrent = is_Defined(option.concurrent)? option.concurrent: this.options.concurrent;\r\n    const onCloud = (is_Defined(option.onCloud)? option.onCloud: !!this.options.outerClear) as boolean;\r\n    this.status = _STATUS.LOADING;\r\n    this._trigger('beforeClear');\r\n    \r\n    // Local clear\r\n    let localClear = ()=>{\r\n      const IgnoreLocal = onCloud && !concurrent;\r\n      this._trigger('beforeLocalClear', IgnoreLocal); // give an status token before invoke.\r\n\r\n      if(IgnoreLocal){\r\n        DEBUG && console.log(`${LogToken}The local clear action is ignored by options: concurrent:false.`);\r\n        return this;\r\n      }\r\n      const localApi = this.options.localInterface;\r\n      localApi.database[localApi.removeItem]( this.__root );\r\n      // trigger hook event after call local database to clear the Item.\r\n      this._trigger('localCleared', this.__root); // Give the param of the remove target. \r\n    }\r\n\r\n    const toEnd = (isSuccess: boolean)=>{\r\n      this.status = _STATUS.IDLE;\r\n      // Callback\r\n      option.onceDone && option.onceDone(isSuccess, onCloud);\r\n      this._trigger('cleared', onCloud, concurrent);\r\n    };\r\n\r\n    // Cloud clear\r\n    const pack = [this.__root, this.__storage];\r\n    const onSuccess = ()=>{\r\n      toEnd(true);\r\n    }\r\n    const onError = (msg, reason='cloudClearings')=>{\r\n      toEnd(false);\r\n\r\n      if(this._trigger(\"error\", \"clear\", reason) !== true ){\r\n        onCloud && console.error(`${LogToken}Failed tfo Clear the cabinet \"${this.__root}\" on cloud. ${msg}`);\r\n      }\r\n    }\r\n\r\n    // handle this async or asyn easily.\r\n    try{\r\n      // Reset the inner cabinet to vacant Object.\r\n      if(option.reset){\r\n        Reflect.ownKeys(this.__storage).forEach(item=>{\r\n          delete this.__storage[item];\r\n        });\r\n      }\r\n\r\n      localClear();\r\n      if(onCloud) \r\n        this.options.outerClear(pack, onSuccess, onError);\r\n      else {\r\n        toEnd(true);\r\n      }\r\n    } catch(e){\r\n      onError(e, \"unknown\");\r\n    }\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Load the cabinet on initialization.\r\n   * The local load is faster than cloud.\r\n   * @param { Boolean } onCloud \r\n   * @param { Boolean } concurrent Override the default options in `this.options.concurrent`\r\n   * @param { Boolean } deepMerge Using deepAssign instead of Object.assign to merge the data from local and cloud.\r\n   */\r\n  Proto.load = function(option: AccessOptions & { disableMerge?: boolean} = {}){\r\n    // merge default options.\r\n    const concurrent = is_Defined(option.concurrent)? option.concurrent: this.options.concurrent;\r\n    const onCloud = (is_Defined(option.onCloud)? option.onCloud: !!this.options.outerLoad) as boolean;\r\n    const deepMerge = is_Defined(option.deepMerge)? ~~(option.deepMerge as Boolean): this.options.deepMerge;\r\n    this.status = _STATUS.LOADING;\r\n    this._trigger(\"beforeLoad\");\r\n\r\n    // Local load \r\n    let localLoad = ()=>{\r\n      let localTemp = null;\r\n      const IgnoreLocal = onCloud && !concurrent;\r\n      this._trigger('beforeLocalLoad', IgnoreLocal); // give an status token before invoke.\r\n\r\n      if(IgnoreLocal){\r\n        DEBUG && console.log(\"${LogToken}The local load action is ignored by options: concurrent=false.\");\r\n        return this;\r\n      }\r\n      const localApi = this.options.localInterface;\r\n      \r\n      let initialData = localApi.database[localApi.getItem]( this.__root );\r\n      // trigger hook event after call local database to parse the value. \r\n      // Should have a return value in event. (data)=>{ return handle(data); }\r\n      initialData = this._trigger('localLoaded', initialData); // Only take effect on the last element.\r\n\r\n      localTemp = JSON.parse( initialData );\r\n      if(deepMerge){\r\n        if(option.disableMerge)\r\n          deepAssign(this.__storage, localTemp);\r\n        else\r\n          deepConditionalAssign(this.__storage, localTemp, this.options.customMerge);\r\n      }else\r\n        Object.assign(this.__storage, localTemp);\r\n    };\r\n\r\n    const toEnd = (isSuccess: boolean)=>{\r\n      this.status = _STATUS.IDLE;\r\n      // Callback\r\n      option.onceDone && option.onceDone(isSuccess, onCloud);\r\n      this._trigger('loaded', onCloud, concurrent);\r\n    }\r\n\r\n    // Cloud load\r\n    const pack = [this.__root, this.__storage];\r\n    const onSuccess = (data)=>{\r\n      if(!is_Defined(data) || !is_PlainObject(data))\r\n        throw new Error(`${LogToken}Load cabinet with empty 'data' which type is ${typeof data}`);\r\n        \r\n      if(deepMerge){\r\n        if(option.disableMerge)\r\n          deepAssign(this.__storage, data);\r\n        else\r\n          deepConditionalAssign(this.__storage, data, this.options.customMerge);\r\n      }else \r\n      // shallow assign makes cloud weight heavier.\r\n        Object.assign(this.__storage, data);\r\n      \r\n      toEnd(true);\r\n    }\r\n    const onError = (msg, reason='cloudLoadings')=>{\r\n      toEnd(false);\r\n\r\n      if(this._trigger(\"error\", \"load\", reason) !== true){\r\n        onCloud && console.error(`${LogToken}Failed to Load the cabinet \"${this.__root}\" on cloud. ${msg}`);\r\n      }\r\n    }\r\n\r\n    // handle this async or asyn easily.\r\n    try{\r\n      localLoad();\r\n      if(onCloud) \r\n        this.options.outerLoad(pack, onSuccess, onError);\r\n      else {\r\n        toEnd(true);\r\n      }\r\n    } catch(e){\r\n      onError(e, \"unknown\");\r\n    }\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Save the cabinet to database or cloud.\r\n   * The event `localSaved` is called before real action for storage hook.\r\n   * @param {*} onCloud \r\n   * @param {Boolean} concurrent Override the default options in `this.options.concurrent`\r\n   */\r\n  Proto.save = function(option: SubSet<AccessOptions, 'deepMerge'> = {}){\r\n    // merge default options.\r\n    const onCloud = (is_Defined(option.onCloud)? option.onCloud: !!this.options.outerSave) as boolean;\r\n    const concurrent = is_Defined(option.concurrent)? option.concurrent: this.options.concurrent;\r\n    \r\n    // check the status for mutex protection\r\n    let check = this.options.saveMutex && !this.isVacant();\r\n    this._trigger(\"beforeSave\", check);\r\n    if( check ){\r\n      DEBUG && console.log(`${LogToken}The 'save' manipulation is deserted for busy. Current Status: ${this.status} .Set 'saveMutex' false to disable it.`);\r\n      this._trigger(\"busy\", this.status);\r\n      this.options.autoLazy && this.lazySave(onCloud, concurrent);\r\n      return this;\r\n    }\r\n    \r\n    this.status = _STATUS.SAVING;\r\n\r\n    // Local save \r\n    let localSave = ()=>{\r\n      const IgnoreLocal = onCloud && !concurrent;\r\n      this._trigger('beforeLocalSave', IgnoreLocal); // give an status token before invoke.\r\n\r\n      if(IgnoreLocal){\r\n        DEBUG && console.log(\"${LogToken}The local save action is ignored by options: concurrent=false.\");\r\n        return this;\r\n      }\r\n      // trigger hook event beforeLocalSave. Should have a return value in event. (data)=>{ return handle(data); }\r\n      let finalData = JSON.stringify(this.__storage );\r\n      // trigger hook event before call local database to save the value for data interceptor.\r\n      finalData = this._trigger('localSaved', finalData); // Only take effect on the last element.\r\n\r\n      const localApi = this.options.localInterface;\r\n      localApi.database[localApi.setItem](this.__root, finalData);\r\n    };\r\n    \r\n    const toEnd = (isSuccess: boolean)=>{\r\n      this.status = _STATUS.IDLE;\r\n      // Callback\r\n      option.onceDone && option.onceDone(isSuccess, onCloud);\r\n      this._trigger('saved', onCloud, concurrent);\r\n    }\r\n\r\n    // Cloud save\r\n    const pack = [this.__root, this.__storage];\r\n    const onSuccess = ()=>{\r\n      toEnd(true);\r\n    }\r\n    const onError = (msg, reason=\"cloudSavings\")=>{\r\n      toEnd(false);\r\n\r\n      if(this._trigger(\"error\", \"save\", reason) !== true){\r\n        onCloud && console.error(`${LogToken}Failed to Save the cabinet \"${this.__root}\" on cloud. ${msg}`);\r\n      }\r\n    }\r\n\r\n    // handle this async or sync easily.\r\n    try{\r\n      localSave();\r\n      if(onCloud) \r\n        this.options.outerSave(pack, onSuccess, onError);\r\n      else {\r\n        toEnd(true);\r\n      }\r\n    } catch(e){\r\n      onError(e, 'unknown');\r\n    }\r\n    return this;\r\n  }\r\n  \r\n  /**\r\n   * Foreach methods support.\r\n   * Iterate the first hierarchy with callback.\r\n   * @param {Function: (item, key, cabinet)=>any }} callback with two params\r\n   */\r\n  Proto.forEach = function(callback: (item: any, key: string, cabinet: Object)=>any){\r\n    let item;\r\n    const cabinet = this.__storage;\r\n    for(let key in cabinet){\r\n      item = cabinet[key];\r\n      callback(item, key, cabinet); // only two params.\r\n    }\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Map methods support.\r\n   * Iterate the first hierarchy with callback.\r\n   * @param {Function: (item, key, cabinet)=>any }} callback  with two params\r\n   * @return { Object } cabinet\r\n   */\r\n  Proto.map = function(callback: (item: any, key: string, cabinet: Object)=>any){\r\n    let item;\r\n    const cabinet = this.__storage;\r\n    for(let key in cabinet){\r\n      item = cabinet[key];\r\n      cabinet[key] = callback(item, key, cabinet); // only two params.\r\n    }\r\n    return cabinet;\r\n  }\r\n\r\n  /**\r\n   * For custom destroy.\r\n   * Call it to clear the sideEffect produce by kinds of plugins.\r\n   */\r\n  Proto.destroy = function(autoClear = false){\r\n    if(autoClear){\r\n      this.clear({\r\n        reset: true,\r\n        onCloud: false,\r\n        concurrent: false,\r\n      });\r\n    }\r\n    \r\n    this.removeStore();\r\n    this.status = _STATUS.DESTROYED;\r\n    this._trigger(\"destroyed\");\r\n  }\r\n\r\n}\r\n","/**\r\n * Lycabinet Status.\r\n */\r\n\r\nconst CREATED = 'created';\r\nconst MOUNTED = 'mounted';\r\nconst IDLE = 'idle';\r\nconst LOADING = 'loading';\r\nconst SAVING = 'saving';\r\nconst CLEARING = 'clearing';\r\nconst DESTROYED = 'destroyed';\r\n\r\nexport {\r\n  CREATED,\r\n  IDLE,\r\n  LOADING,\r\n  SAVING,\r\n  CLEARING,\r\n  MOUNTED,\r\n  DESTROYED\r\n};\r\n","/**\r\n * Lazy methods support.\r\n * @param {*} Lycabinet \r\n */\r\nimport { DEBUG } from \"@/utils/util\";\r\n\r\nexport function InitLazyDepartment(Lycabinet){\r\n  \r\n  /**\r\n   * Add lazySave support.\r\n   * The params is the same to save methods.\r\n   */\r\n  Lycabinet.prototype.lazySave = (function(){\r\n    var lastTime = 0; // throttle\r\n    var timerHandle: NodeJS.Timeout; // debounce\r\n    return function(...params){\r\n      var nowTime = new Date().getTime();\r\n      // The gap is not so accurate but enough.\r\n      let judge = (nowTime - lastTime) > this.options.lazyPeriod;\r\n      this._trigger(\"lazySave\", judge);\r\n\r\n      clearTimeout(timerHandle);\r\n      if (judge) {\r\n        // Use default settings\r\n        DEBUG && console.log(\"Lazy executed!\", nowTime, lastTime, judge)\r\n        this.save(...params);\r\n      } else {\r\n        timerHandle = setTimeout(()=>{\r\n          this.save(...params);\r\n        }, nowTime - lastTime);\r\n      }\r\n      lastTime = nowTime;\r\n      return this;\r\n    }\r\n  })();\r\n\r\n  /**\r\n   * Just calling lazySave after save called.\r\n   * @param {*} key \r\n   * @param {*} value \r\n   * @param {...any} params parameters to lazySave (). \r\n   */\r\n  Lycabinet.prototype.lazySet = function(key, value, ...params){\r\n    this.set(key, value).lazySave(...params);\r\n    return this;\r\n  }\r\n}","/**\r\n * Lycabinet Mixin.\r\n */\r\nexport function InitMixin(Lycabinet){\r\n  Lycabinet.prototype._mixins = []; // Shared by instances.\r\n\r\n  Lycabinet.mixin = function (mixinFunc) {\r\n    Lycabinet.prototype._mixins.push(mixinFunc);\r\n    return this;\r\n  };\r\n\r\n  Lycabinet.prototype.__install = function(...options){\r\n    options.unshift(this);\r\n    Lycabinet.prototype._mixins.forEach(func => {\r\n      func.apply(func, options);\r\n    });\r\n  };\r\n}","/**\r\n * Add alias to some methods.\r\n * To custom the using habit for general users.\r\n */\r\n\r\nexport function initAlias(Lycabinet){\r\n  const Proto = Lycabinet.prototype;\r\n  \r\n  Proto.delete = Proto.remove;\r\n\r\n  Proto.read = Proto.get;\r\n  Proto.write = Proto.set;\r\n\r\n  Proto.storage = Proto.getCabinet;\r\n\r\n  Proto.isConsistent = Proto.isIdentical;\r\n}"],"names":["__webpack_require__","exports","definition","key","o","Object","defineProperty","enumerable","get","obj","prop","prototype","hasOwnProperty","call","curveSet","source","objPathes","value","interim","item","index","length","is_Defined","is_Object","is_Function","invokeQueue","window","addEventListener","eve","forEach","func","deepAssign","objs","merged","reduce","target","is_PlainObject","deepConditionalAssign","condition","v","toString","Function","LogToken","Lycabinet","options","this","__init","apply","__cabinet","create","__insTable","Proto","getCabinet","__storage","isIdentical","__root","hasStore","getStore","setStore","cabinet","removeStore","useSharedCabinet","shareCabinet","size","$removeStore","root","mixin","cabinetIns","_on","Set","add","delete","InitStore","Protos","NoopFunc","mtd","InitEventSystem","DEBUG","SeparateLog","initStorage","Error","str","constructor","String","defaultOptions","autoload","lazyPeriod","saveMutex","autoLazy","logEvent","deepMerge","customMerge","localInterface","database","localStorage","getItem","setItem","removeItem","concurrent","outerLoad","outerSave","outerClear","__install","_setlog","status","_trigger","_init","writeBackflow","val","__tempStorage","Array","isArray","slice","keys","isLoadFromCache","assign","load","isVacant","set","indexOf","split","backValue","curveGet","remove","removed","input","k","clear","option","onCloud","localClear","IgnoreLocal","localApi","toEnd","isSuccess","onceDone","pack","onSuccess","onError","msg","reason","console","error","reset","Reflect","ownKeys","e","localLoad","localTemp","initialData","JSON","parse","disableMerge","data","save","check","lazySave","localSave","finalData","stringify","callback","map","destroy","autoClear","InitCore","timerHandle","lastTime","params","nowTime","Date","getTime","judge","clearTimeout","setTimeout","lazySet","InitLazyDepartment","_mixins","mixinFunc","push","unshift","InitMixin","read","write","storage","isConsistent","initAlias"],"sourceRoot":""}