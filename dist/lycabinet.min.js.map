{"version":3,"file":"lycabinet.min.js","mappings":"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","sources":["webpack://Lycabinet/webpack/universalModuleDefinition","webpack://Lycabinet/webpack/bootstrap","webpack://Lycabinet/webpack/runtime/define property getters","webpack://Lycabinet/webpack/runtime/hasOwnProperty shorthand","webpack://Lycabinet/./src/utils/util.ts","webpack://Lycabinet/./src/utils/status.ts","webpack://Lycabinet/./src/extends/observer.ts","webpack://Lycabinet/./src/extends/check.ts","webpack://Lycabinet/./src/index.ts","webpack://Lycabinet/./src/core/store.ts","webpack://Lycabinet/./src/core/mixin.ts","webpack://Lycabinet/./src/core/event.ts","webpack://Lycabinet/./src/core/lycabinet.ts","webpack://Lycabinet/./src/core/lazy-support.ts","webpack://Lycabinet/./src/core/immbedding.ts","webpack://Lycabinet/./src/extends/alias.ts","webpack://Lycabinet/./src/extends/filter.ts","webpack://Lycabinet/./src/extends/zip.ts"],"sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"Lycabinet\", [], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"Lycabinet\"] = factory();\n\telse\n\t\troot[\"Lycabinet\"] = factory();\n})(self, function() {\nreturn ","// The require scope\nvar __webpack_require__ = {};\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","/**\r\n * Utils.js.\r\n * By lozyue.\r\n */\r\n\r\n/**\r\n * Get the item in an array with index. Support negative index.\r\n * @param  {...any} objs \r\n */\r\nexport const arrayIndex = function (arr, index) {\r\n  index = (arr.length + index) % arr.length;\r\n  if (arr[index] === undefined) {\r\n    throw new Error(`The index ${index} in array ${arr.toString()} is overflowed!`);\r\n  }\r\n  return arr[index];\r\n}\r\n\r\n/**\r\n * Get the target curve path value of the source Object.\r\n * The curve path is a sequenced array\r\n * @param source \r\n * @param objPathes \r\n */\r\nexport function curveGet(source: Object, objPathes: string[]){\r\n  let interim = source, item = '';\r\n  for(let index=0; index<objPathes.length; index++){\r\n    item = objPathes[index];\r\n    interim = interim && interim[item]\r\n    if(interim === void 0 ){\r\n      return void 0;\r\n    };\r\n  }\r\n  return interim;\r\n}\r\n\r\n/**\r\n * Set the consistent even curve path of the source Object \r\n * The curve path is a sequenced array // dot split strings.\r\n * @param source \r\n * @param objPathes \r\n * @param {unknown|Function} value The value assign for the curve object target. Support callback that if target value is a function you should set it in call back.\r\n * @returns { number|true } The number indicator the failed position of the conflict path.\r\n */\r\n export function curveSet(source: Object, objPathes: string[], value: ((target: Object, name: string)=>any)| unknown= null){\r\n  let interim = source, item = '';\r\n  // not the last one.\r\n  let index=0;\r\n  for(; index<objPathes.length-1; index++){\r\n    item = objPathes[index];\r\n    if(is_Defined(interim[item]) ){\r\n      if(is_Object(interim[item])){\r\n        interim = interim[item];\r\n      } else {\r\n        // Unexpected non-object value.\r\n        return index;\r\n      }\r\n    } else \r\n      interim = interim[item] = {};\r\n  };\r\n  // the last\r\n  item = objPathes[index];\r\n  // assign the value.\r\n  if(is_Function(value))\r\n    (value as Function)(interim, item);\r\n  else\r\n    interim[item] = value;\r\n  return true;\r\n}\r\n\r\n/**\r\n * Centralized management.\r\n * Add a listener to window storage event.\r\n * @param { Function } invoke Target invoke function or handle. \r\n * @param { Boolean } remove wheather the action is to remove added storage listener.\r\n */\r\nexport const addStoreListener = (()=>{\r\n  const invokeQueue: Function[]= [];\r\n  window.addEventListener(\"storage\", (eve)=>{\r\n    invokeQueue.forEach(func=>{\r\n      func(eve);\r\n    });\r\n  }, false); // default bubble.\r\n\r\n  return (invoke, remove = false)=>{\r\n    if(remove) \r\n      removeArrayItem(invokeQueue, invoke);\r\n    else invokeQueue.push(invoke);\r\n  }\r\n})();\r\n\r\n/**\r\n * Deep Object.assign source to target.\r\n * @param target\r\n * @param source\r\n */\r\nexport const deepAssign = function (...objs) {\r\n  let merged;\r\n  objs.reduce((target, source) => {\r\n    for (let item in source) {\r\n      if (!(target[item] && is_PlainObject(target[item])) ) {\r\n        target[item] = source[item];\r\n      } else {\r\n        deepAssign(target[item], source[item]);\r\n      }\r\n    }\r\n    merged = target;\r\n    return target;\r\n  }, objs[0]); // The third param is to set default value.\r\n  return merged;\r\n}\r\n\r\n/**\r\n * Just assign the item in supplement which not defined in target.\r\n * If you don't want to override the value of origin Object, supplement is the high performance choice.\r\n * Not deep mode.\r\n * @param {*} target \r\n * @param {*} supplement \r\n */\r\nexport function objectSupplement(target, supplement) {\r\n  let current = null;\r\n  for (let item in supplement) {\r\n    current = target[item];\r\n    if (is_Defined(current))\r\n      continue;\r\n    target[item] = supplement[item];\r\n  }\r\n  return target;\r\n}\r\n\r\n/**\r\n * Just assign the item in supplement which not defined in target.\r\n * If you don't want to override the value of origin Object, supplement is the high performance choice.\r\n * Deep mode by iterate each inner Object.\r\n * @param {*} target \r\n * @param {*} supplement \r\n */\r\nexport function deepSupplement<R extends Object, T extends Object> (target: R|null, supplement: T) {\r\n  if(!target) return supplement;\r\n  let current: unknown = null;\r\n  for (let item in supplement) {\r\n    current = (target as unknown as T)[item];\r\n    if (is_Defined(current)) {\r\n      if (!is_PlainObject(current as Object)) continue;\r\n      deepSupplement(current as Object, supplement[item]); // The `current` is a reference which could be assigned.\r\n    }\r\n    else\r\n      // current = supplement[item];\r\n      (target as unknown as T)[item] = supplement[item];\r\n  }\r\n  return target as (R & T);\r\n}\r\n\r\n\r\n/**\r\n * Simple deepClone with optional Function clone\r\n */\r\nexport function deepClone(val, substituteObj = Object.create(null), cloneFunc = true) {\r\n  if (is_PlainObject(val)) {\r\n    var res = substituteObj;\r\n    for (var key in val) {\r\n      res[key] = deepClone(val[key]);\r\n    }\r\n    return res;\r\n  } else if (is_Array(val)) {\r\n    return val.slice()\r\n  } else if (cloneFunc && is_Function(val)) {\r\n    return Object.create(val.prototype).constructor;\r\n  } else {\r\n    return val;\r\n  }\r\n}\r\n\r\nexport function iterateObject(source: Object, iterate: Function){\r\n  iterate(source);\r\n  for(let item in source){\r\n    if( is_PlainObject(source[item]) )\r\n      iterate(source, iterate);\r\n  }\r\n}\r\n\r\nexport const is_Defined = (v: unknown):Boolean => (v !== undefined && v !== null);\r\nexport const is_Object = (obj: unknown):Boolean => (obj instanceof Object || typeof obj === \"object\");\r\nexport const is_PlainObject = (obj: unknown):Boolean => (Object.prototype.toString.call(obj) === '[object Object]');\r\nexport const is_Array = (obj: unknown):Boolean => (Array.isArray && Array.isArray(obj) || obj instanceof Array || (typeof obj === 'object') && Object.prototype.toString.call(obj).slice(-6,-1)=== 'Array' );\r\nexport const is_String = (str: Object):Boolean => ((typeof str === 'string') && str.constructor == String);\r\nexport const is_Function = (obj: unknown):Boolean => (obj instanceof Function);\r\n\r\nexport const is_Empty = (val: unknown)=>{\r\n  if(!val) return true;\r\n  if(is_Array(val)){\r\n    return !(val as Array<unknown>).length;\r\n  }else{\r\n    return !Object.keys((val) as Object).length;\r\n  }\r\n}\r\n\r\n/*\r\n * Delete the Item in an Array, returning the new Array.\r\n */\r\nexport var removeArrayItem = (arr, item) => {\r\n  if (arr.length) {\r\n    let index = arr.indexOf(item);\r\n    if (index > -1) {\r\n      return arr.splice(index, 1);\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n * Provide with a processor accept a list of stuff or single stuff\r\n * Give it the action to its inner iterator.\r\n * The original Stuff can not be an Array!\r\n */\r\nexport function arbitraryFree(input, func) {\r\n  if (input.forEach) {\r\n    return input.forEach(func);\r\n  } else {\r\n    return func(input, 0);\r\n  }\r\n}\r\n\r\nexport function storageAvailable(type) {\r\n  var storage;\r\n  try {\r\n    storage = window[type];\r\n    var x = '__storage_test__';\r\n    storage.setItem(x, x);\r\n    storage.removeArrayItem(x);\r\n    return true;\r\n  }\r\n  catch (e) {\r\n    return e instanceof DOMException && (\r\n      // everything except Firefox\r\n      e.code === 22 ||\r\n      // Firefox\r\n      e.code === 1014 ||\r\n      // test name field too, because code might not be present\r\n      // everything except Firefox\r\n      e.name === 'QuotaExceededError' ||\r\n      // Firefox\r\n      e.name === 'NS_ERROR_DOM_QUOTA_REACHED') &&\r\n      // acknowledge QuotaExceededError only if there's something already stored\r\n      (storage && storage.length !== 0);\r\n  }\r\n}\r\n\r\nexport const LogToken = \"[Lycabinet]: \";\r\n\r\nexport const DEBUG = process.env.NODE_ENV !== 'production';\r\n\r\nexport const EnvAssociate = {\r\n  Light: false, // light mode.\r\n};\r\n","/**\r\n * Status for Mutex\r\n */\r\n\r\nconst CREATED = 'created';\r\nconst MOUNTED = 'mounted';\r\nconst IDLE = 'idle';\r\nconst LOADING = 'loading';\r\nconst SAVING = 'saving';\r\nconst CLEARING = 'clearing';\r\n\r\n\r\nexport {\r\n  CREATED,\r\n  IDLE,\r\n  LOADING,\r\n  SAVING,\r\n  CLEARING,\r\n  MOUNTED,\r\n};\r\n","/**\r\n * Observer Plugin for Lycabinet\r\n * Adding an mini observer for storage variable listening.\r\n */\r\n\r\nimport { \r\n  curveGet, curveSet, \r\n  removeArrayItem, deepSupplement, is_PlainObject,  \r\n  DEBUG,\r\n  is_Function,\r\n  LogToken\r\n} from \"../utils/util\";\r\n\r\n// change methods.\r\nlet onSetted: Function| null = null;\r\n\r\n/**\r\n * Targets\r\n * @param Lycabinet \r\n */\r\n\r\nexport function addObserver(Lycabinet){\r\n  Lycabinet.prototype.initObserver = function(options: any = {}){\r\n    // Override the default options\r\n    Object.assign(options, {\r\n      deepMerge: true,\r\n    });\r\n    // configurate options\r\n    deepSupplement(options, {\r\n      lazy: true,\r\n      initWatch: true, // whether transform the origin property in Observer.\r\n      deepWatch: true, // whether consistently watch the Object type value setted in initial data.\r\n      shallowWatch: false, // whether just watch the surface of the Object.\r\n    });\r\n\r\n    // init proxy Interceptor.\r\n    onSetted = ()=>{\r\n      // this._trigger(\"setItem\");\r\n      options.lazy? this.lazySave(): this.save();\r\n    };\r\n    \r\n    if(!options.initWatch) return false;\r\n    \r\n    this.__storage = deepConvert(this.__storage, options.deepWatch, options.shallowWatch);\r\n    this.setStore(this.__storage);\r\n  };\r\n\r\n  // Convert the path target to be reactive. Check redundant Prevent by default.\r\n  Lycabinet.$set = function(target, pathList: string[], deep=false, shallow =true){\r\n\r\n    // CurveSet the target value.\r\n    return curveSet(target, pathList, (innerTarget, kname)=>{\r\n      // If target is not existed, set to plain Object; Reset the value if it has been converted.\r\n      if(!is_PlainObject(innerTarget[kname])){\r\n        innerTarget[kname] = {};\r\n      }\r\n      if(DEBUG && innerTarget[kname][\"$addListener\"]){\r\n        console.warn(`${LogToken}The target have been converted before!`, innerTarget[kname]);\r\n      }\r\n      innerTarget[kname] = convert(innerTarget[kname], deep, shallow);\r\n    });\r\n  };\r\n\r\n  Lycabinet.$get = function(target, pathList: string[]){\r\n    return curveGet(target, pathList);\r\n  }\r\n\r\n  /**\r\n   * Makes the target to be reactive\r\n   * If the target path is not defined,\r\n   *  it will be assigned as an Object.\r\n   * Warning: If the value in path end is assigned with non-PlainObject type value previously,\r\n   *  the value will be override by `{}`\r\n   */ \r\n  Lycabinet.prototype.$set = function(pathName: string, deep=false, shallow =true){\r\n    return Lycabinet.$set(this.__storage, pathName.split('.'), deep, shallow);\r\n  }\r\n  // Makes the target to be reactive\r\n  Lycabinet.prototype.$get = function(pathName: string){\r\n    return curveGet(this.__storage, pathName.split('.') );\r\n  }\r\n};\r\n\r\n/**\r\n * Proxy Modules.\r\n * @author lozyue\r\n * @time 2021\r\n */\r\n\r\n// Convert the Object and its descendant Object from bottom to top.\r\nfunction deepConvert(source: Object, deepWatch=true, shallowWatch=false){\r\n  const plainObjQueue: Array<any> = [];\r\n  // reverse for convert\r\n  const iterate = (current)=>{\r\n    plainObjQueue.unshift(current);\r\n    for(let item in current){\r\n      if(is_PlainObject(current[item])){\r\n        iterate(current[item]);\r\n      }\r\n    }\r\n  };\r\n  iterate(source);\r\n  plainObjQueue.forEach((item, index, arr)=>{\r\n    for(let ref in item){\r\n      // convert by reference.\r\n      if(is_PlainObject(item[ref]) )\r\n        arr[index][ref] = convert(item[ref], deepWatch, shallowWatch);\r\n    }\r\n  });\r\n  return convert(source, deepWatch, shallowWatch);\r\n}\r\n\r\n/**\r\n * Convert the normal data to be reactive.\r\n *  todo: add the Array type support.\r\n * @param source \r\n * @param deepWatch \r\n * @param shallowWatch \r\n */\r\ntype OnValueChange = (prop:symbol|string, newValue, oldValue)=>unknown;\r\ntype InternalValueType = {\r\n  _parent: null | unknown,\r\n  $addListener: (t:OnValueChange, onProp: string)=>unknown,\r\n  $removeListener: (h:OnValueChange, onProp: string)=>unknown,\r\n  // trigger: Record<string|symbol, OnValueChange[]>,\r\n  triggers: OnValueChange[],\r\n  value: Object,\r\n};\r\nfunction convert(source: Object, deepWatch = false, shallowWatch = true){\r\n  let internalValue: InternalValueType = Object.create(null);\r\n  // to do... Add trigger bubbule to its parents.\r\n  internalValue._parent = null;\r\n  internalValue.triggers = [];\r\n  // save the values\r\n  internalValue.value = source;\r\n  // Config it!\r\n  const propConfig = {\r\n    enumerable: false, // which is not enumerable in source either.\r\n    configurable: true,\r\n    writable: false,\r\n  };\r\n  const $addListener = (onchange: OnValueChange)=>{    \r\n    return internalValue.triggers.push(onchange);\r\n  };\r\n  const $removeListener = (handle: Function)=>{\r\n    return removeArrayItem(internalValue.triggers, handle);\r\n  };\r\n  // Origin Accessable definition\r\n  const AccessQueue = [\"$addListener\", \"$removeListener\"];\r\n  AccessQueue.forEach((hook, index)=>{\r\n    internalValue[hook] = {value: null} as {value: unknown, trigger: Function[]};\r\n    Object.defineProperty(internalValue, hook, {\r\n      value: !index? $addListener: $removeListener,\r\n      ...propConfig\r\n    });\r\n  });\r\n\r\n  const refValue = internalValue.value; // For reader accel.\r\n  const HandleRules = {\r\n    get(target, prop, receiver) {\r\n      DEBUG && console.info(\"Getted\", target, prop, receiver, internalValue);\r\n      if(AccessQueue.indexOf(prop) > -1){\r\n        return internalValue[prop];\r\n      }\r\n      return refValue[prop];\r\n    },\r\n    set(target, prop, newValue, receiver) {\r\n      DEBUG && console.info(\"Setted\", target, prop, receiver, internalValue);\r\n      const rawValue = refValue[prop];\r\n      // consistent deepWatch observer. \r\n      if(deepWatch){\r\n        if(is_PlainObject(newValue)){\r\n          if(shallowWatch){\r\n            refValue[prop] = convert(newValue, false, true);\r\n          }else{\r\n            refValue[prop] = deepConvert(newValue, deepWatch, false);\r\n          }\r\n        }\r\n      }else\r\n        refValue[prop] = newValue;\r\n\r\n      if(newValue !== rawValue){\r\n        let triggers = internalValue.triggers;\r\n        for(let index=0; index< triggers.length; index++){\r\n          // Check it!\r\n          if(!is_Function(triggers[index]) ){\r\n            throw new Error(`The get proxy handler listener added in target is Not a Function which type is ${typeof triggers[index]}`);\r\n          }\r\n          triggers[index](prop, newValue, rawValue);\r\n        }\r\n        if(onSetted!==null) onSetted();\r\n      }\r\n      return true;\r\n    },\r\n  };\r\n  return new Proxy(source, HandleRules);\r\n}\r\n","/**\r\n * Argument the robustness of the JSON data process.\r\n * And preserve the atomicity when there is multi-tabs opened by user.\r\n * Like delete the Item in Storage if it is vacant.\r\n */\r\n\r\nimport { addStoreListener, arrayIndex, DEBUG, objectSupplement } from \"../utils/util\";\r\n\r\nconst ParticalToken = 'cabinetSyncTabs';\r\n\r\nexport function addCheck(Lycabinet){\r\n  /**\r\n   * JSON analysis argumented.\r\n   */\r\n  Lycabinet.mixin(function(cabinetIns){\r\n    cabinetIns._on(\"localLoaded\", function(finalData, results){\r\n      let final = results.length? arrayIndex(results, -1): finalData;\r\n      // add pre-check for JSON Parse.\r\n      if(!final) final = '{}';\r\n      return final;\r\n    });\r\n    cabinetIns._on(\"localSaved\", function(finalData, results){\r\n      let final = results.length? arrayIndex(results, -1): finalData;\r\n      return final;\r\n    });\r\n  });\r\n\r\n  /**\r\n   * Add a dirty flag for judging.\r\n   */\r\n  Lycabinet.mixin(function(cabinetIns){\r\n    // This is not so precious. Because user can manually set the __storage Object whose action is not recorded.\r\n    cabinetIns._on(\"setItem\", function(){\r\n      this._dirty = true;\r\n    });\r\n    cabinetIns._on(\"saved\", function(){\r\n      this._dirty = false;\r\n    })\r\n  });\r\n\r\n  /**\r\n   * Listening the storage event from other tabs(pages)\r\n   *  Custom Events: `storageSync`\r\n   */\r\n  var localContext: {cabinetIns?: Record<string, unknown>} = {};\r\n  addStoreListener( (eve)=>{\r\n    if(!localContext.cabinetIns){\r\n      DEBUG && console.warn(\"cabinetIns is not mouted!\");\r\n      return true;\r\n    }\r\n\r\n    const { cabinetIns: cabinetIns } = localContext;\r\n    \r\n    // Do not do redundant reload if current cabinet is shared by another.\r\n    // We think that in one page the cabinet has the same root is always shared, but there are troubles if\r\n    //  the first instance is collected by GC.\r\n    if(cabinetIns.useLoadCache) return true;\r\n\r\n    // Reload. By default using deeepMerge mode.\r\n    if([cabinetIns.__root, ParticalToken].indexOf(eve.key) > -1){\r\n      DEBUG && console.log(\"[Lycabinet]: Synchronizing data from other tabs...\");\r\n      // merge data using default options.\r\n      (cabinetIns.load as Function)({\r\n        onCloud: false, \r\n        concurrent: true, \r\n        deepMerge: true\r\n      }); // Considering of the latency on cloud, we only synchronize the data locally.\r\n      (cabinetIns._trigger as Function)(\"storageSync\");\r\n    }\r\n  });\r\n\r\n  /**\r\n   * Add auto tab synchronize listener options.\r\n   */\r\n  Lycabinet.mixin(function(cabinetIns){\r\n    // save the localContext\r\n    localContext.cabinetIns = cabinetIns;\r\n    cabinetIns._on(\"loadFromCache\", function(){\r\n      this.useLoadCache = true; \r\n    });\r\n\r\n    // add options for custom database which is not localStorage.\r\n    objectSupplement(cabinetIns.options, {\r\n      autoNotifyTabs: cabinetIns.options.localInterface.database===window.sessionStorage,\r\n    });\r\n\r\n    cabinetIns._on(\"saved\", function(onCloud, concurrent){\r\n      if(this.options.autoNotifyTabs){\r\n        const IgnoreLocal = onCloud && !concurrent;\r\n        if(IgnoreLocal){\r\n          return false;\r\n        }\r\n\r\n        this.notifyTabs();\r\n      }\r\n    });\r\n  });\r\n\r\n  /**\r\n   * If the database in configuration is not `LocalStorage` (like Env is `sessionStorage`)\r\n   * You should call this method to notify the other pages or set autoNotifyTabs to true.\r\n   */\r\n  Lycabinet.prototype.notifyTabs = function(){\r\n    const randomToken = new Date().getTime();\r\n    // this will give other pages a notifycation.\r\n    window.localStorage.setItem(ParticalToken, randomToken+'');\r\n  }\r\n}\r\n","/**\r\n * Lycabinet.js\r\n * Full build.\r\n */\r\n\r\nimport { InitStore } from './core/store';\r\nimport { InitEventSystem } from './core/event';\r\nimport { InitCore } from './core/lycabinet';\r\nimport { InitLazyDepartment } from './core/lazy-support';\r\nimport { InitMixin } from \"./core/mixin\";\r\n\r\nimport { initImbedding } from './core/immbedding';\r\nimport { initAlias } from './extends/alias';\r\nimport { addFilter } from './extends/filter';\r\nimport { addObserver } from './extends/observer';\r\n\r\nimport { addCheck } from './extends/check';\r\nimport { addZip } from './extends/zip';\r\n\r\n\r\nfunction Lycabinet(...options){\r\n  if (process.env.NODE_ENV !== 'production' && !(this instanceof Lycabinet) ) {\r\n    (global.warn || console.warn)('Lycabinet is a constructor and should be called with the `new` keyword');\r\n    return null;\r\n  }\r\n  this.__init.apply(this, options);\r\n}\r\n\r\nInitStore(Lycabinet);\r\nInitMixin(Lycabinet);\r\nInitEventSystem(Lycabinet);\r\nInitCore(Lycabinet);\r\nInitLazyDepartment(Lycabinet);\r\n\r\ninitImbedding(Lycabinet);\r\ninitAlias(Lycabinet);\r\n\r\naddFilter(Lycabinet);\r\naddObserver(Lycabinet);\r\n\r\naddCheck(Lycabinet);\r\naddZip(Lycabinet);\r\n\r\nexport default Lycabinet;\r\n","/**\r\n * Given a private variable for every set storage.\r\n * Basement.\r\n */\r\n\r\nimport { DEBUG, is_Defined, is_PlainObject } from \"../utils/util\";\r\n\r\nexport function InitStore(Lycabinet){\r\n  const __cabinet = Object.create(null);\r\n\r\n  Lycabinet.prototype.hasStore = function(){\r\n    return is_Defined(__cabinet[this.__root]) && is_PlainObject(__cabinet[this.__root]);\r\n  }\r\n\r\n  /**\r\n   * Get the cabinet access.\r\n   * @returns {Plain Object} __cabinet ; The reference of the storage Object property.\r\n   * Each instance is shared by the root key.\r\n   */\r\n  Lycabinet.prototype.getStore = function(){\r\n    return __cabinet[this.__root];\r\n  }\r\n  \r\n  /**\r\n   * To initialize the __cabinet storage. \r\n   * @param {Plain Object} cabinet \r\n   */\r\n  Lycabinet.prototype.setStore = function(cabinet){\r\n    __cabinet[this.__root] = cabinet;\r\n  }\r\n\r\n  /**\r\n   * To clear the inner cache of cabinet.\r\n   */\r\n  Lycabinet.prototype.removeStore = function(){\r\n    __cabinet[this.__root] = void 0;\r\n  }\r\n\r\n  Lycabinet.$removeStore = function(root: string){\r\n    __cabinet[root] = void 0;\r\n  }\r\n\r\n  DEBUG && (Lycabinet.$getStore = function(root: string){\r\n    return __cabinet[root];\r\n  });\r\n}\r\n","/**\r\n * Lycabinet Mixin.\r\n */\r\nexport function InitMixin(Lycabinet){\r\n  Lycabinet.prototype._mixins = []; // Shared by instances.\r\n\r\n  Lycabinet.mixin = function (mixinFunc) {\r\n    Lycabinet.prototype._mixins.push(mixinFunc);\r\n    return this;\r\n  };\r\n\r\n  Lycabinet.prototype.__install = function(...options){\r\n    options.unshift(this);\r\n    Lycabinet.prototype._mixins.forEach(func => {\r\n      func.apply(func, options);\r\n    });\r\n  };\r\n}","/**\r\n * Event system provided.\r\n * Have weak hook fundamental at same time.\r\n */\r\nimport { removeArrayItem, is_Function, DEBUG, arrayIndex, EnvAssociate } from '../utils/util';\r\n\r\nexport function InitEventSystem(Lycabinet){\r\n  // let subscriptions = Object.create(null);\r\n  \r\n  // Private way of Function Clone with more memory cost(About three than normal prototype mode).\r\n  let preOwnner = null;\r\n  Lycabinet.mixin(function(self){\r\n    let subscriptions: Object = null as unknown as Object; \r\n\r\n    if(self!==preOwnner){\r\n      subscriptions = Object.create(null);\r\n    }\r\n    preOwnner = self;\r\n\r\n    self._on = function(name: CabinetEventType, func){\r\n      if(DEBUG &&!is_Function(func)){\r\n        throw new Error(\"[Laction]:The second parameter of _on method must be a callback function!\");\r\n      }\r\n      // console.log(this, , subscriptions)\r\n      subscriptions||(subscriptions = Object.create(null))\r\n      const actions = subscriptions[name] || (subscriptions[name] = []);\r\n      actions.push(func);\r\n    };\r\n    \r\n    self._off = function(name: CabinetEventType, handle){\r\n      const actions = subscriptions[name] || (subscriptions[name] = []);\r\n      removeArrayItem(actions, handle);\r\n    };\r\n  \r\n    self._trigger = function(name: CabinetEventType, ...params){\r\n      const actions = subscriptions[name] || (subscriptions[name] = []);\r\n      const results: Array<unknown>= [];\r\n      params.push(results);\r\n      for(let index=0; index< actions.length; index++){\r\n        let temp = actions[index].apply(this, params);\r\n        temp && results.push( temp );\r\n      }\r\n      // add trigger mark\r\n      if(!actions.counter) actions.counter=0;\r\n      actions.counter++;\r\n      // if no hook this will returns last params. We can use last params to set default value.\r\n      return results.length? arrayIndex(results, -1): params.length? arrayIndex(params, -1): null;\r\n    };\r\n  \r\n    self._once = function(name: CabinetEventType, func, instantOnTriggered: number|boolean = 0){\r\n      const subs = subscriptions[name] || (subscriptions[name] = []);\r\n      if(subs.counter && instantOnTriggered!==false && ~~instantOnTriggered <= subs.counter ){\r\n        func(subs.counter);\r\n        return ;\r\n      }\r\n      var handleFunc = function(...params){\r\n        func.apply(this, params);\r\n        this._off(name, handleFunc);\r\n      }; \r\n      this._on(name, handleFunc);\r\n    };\r\n\r\n    self._isHappend = function(name: CabinetEventType){\r\n      return (subscriptions[name] || (subscriptions[name] = [])).counter > 0;\r\n    }\r\n  \r\n    // for Debug\r\n    // DEBUG && \r\n    !EnvAssociate.Light && (self._setlog = function(){\r\n      if(!Lycabinet.DEBUG) return false;\r\n\r\n      const presets: CabinetEventType[] = [\r\n        'created','mounted', \r\n        'beforeLoad', 'beforeLocalLoad', 'localLoaded', 'loaded', \r\n        'loadFromCache',\r\n        'storageSync',\r\n        'setItem', 'writeLock', 'writeBackflow', \r\n        'getItem', 'removeItem', \r\n        'lazySave', \r\n        'beforeSave', 'beforeLocalSave', 'localSaved', 'saved', 'busy',\r\n        'beforeClear', 'beforeLocalClear', 'localCleared', 'cleared',\r\n        'error', 'destroied',\r\n      ];\r\n  \r\n      new Set(Object.keys(subscriptions).concat(presets) ).forEach(item=>{\r\n        let testHandle = subscriptions[item] && subscriptions[item]._logHandle;\r\n        if(testHandle){\r\n          this._off(item, testHandle)\r\n        }\r\n        // give a handle\r\n        const logHandle = ()=>{\r\n          Lycabinet.DEBUG &&\r\n          console.log(`[Lycabinet${Lycabinet.SeparateLog?'-'+this.__root:''}]:Triggered the event: '${item}'`);\r\n        };\r\n        this._on(item, logHandle);\r\n        // add handle\r\n        subscriptions[item]._logHandle = logHandle;\r\n      });\r\n      return true;\r\n    });\r\n    \r\n  });\r\n}\r\n\r\nexport type CabinetEventType =\r\n'created'|'mounted'| \r\n'beforeLoad'| 'beforeLocalLoad'| 'localLoaded'| 'loaded'| \r\n'loadFromCache'|\r\n'storageSync'|\r\n'setItem'| 'writeLock'| 'writeBackflow'| \r\n'getItem'| 'removeItem'| \r\n'lazySave'| \r\n'beforeSave'| 'beforeLocalSave'| 'localSaved'| 'saved'| 'busy'|\r\n'beforeClear'| 'beforeLocalClear'| 'localCleared'| 'cleared'|\r\n'error'|\r\n'destroied';\r\n","/**\r\n * lycabinet.js\r\n * A high performance JSON Object storage helper.\r\n * 高性能的 JSON对象 小型数据存储辅助类\r\n * @createdTime 2021-03-28\r\n */\r\n\r\nimport * as _STATUS from '@/utils/status';\r\nimport { LogToken } from '@/utils/util';\r\nimport { deepAssign, arbitraryFree, is_Defined, is_PlainObject, DEBUG, is_Empty, is_String } from '@/utils/util';\r\n\r\ntype AccessOptions = Partial<{\r\n  onCloud: boolean|null, \r\n  concurrent: boolean|null,\r\n  deepMerge: boolean|null,\r\n  onceDone: (isSuccess: boolean, isCloud: boolean)=>unknown,\r\n}>\r\n\r\n/**\r\n * Init core.\r\n * @param {*} root \r\n * @param {Object} options => {\r\n *   initStorage => Object, // 初始化值\r\n *   outerSave => Function, // 自定义保存方法，接收一个参数，为存储的数据对象\r\n *   outerLoad => Function, // 自定义装载方法，返回一个对象，将Assign给数据存储对象\r\n * }\r\n * 注意：以上网络请求的外部通信方法需要返回一个Promise对象.\r\n */\r\nexport function InitCore(Lycabinet){\r\n  // Constructor Options\r\n  Lycabinet.DEBUG = true;\r\n  Lycabinet.SeparateLog = false;\r\n\r\n  const Proto = Lycabinet.prototype;\r\n  /**\r\n   * The configuration initialization.\r\n   * @param { String } root \r\n   * @param { Object } options \r\n   */\r\n  Proto.__init = function(root: string, options: Record<string, unknown> = {} ){\r\n\r\n    if(options.initStorage && !is_PlainObject(options.initStorage) ){\r\n      throw new Error(`${LogToken}The type of the provided option \"initStorage\" must be an Object!`);\r\n    }\r\n    if( !is_String(root)) \r\n      throw new Error(`${LogToken}The param \"root\" should be an string, than type ${typeof root}!`);\r\n    this.__root = (root || 'lycabinet') + ''; // The key in storage. Must be a string.\r\n\r\n    // default options.\r\n    const defaultOptions = {\r\n      root: this.__root, // copy to options.\r\n      autoload: true, // 实例化后 自动调用._init 方法实例化. (并且此时init中会自动调用 load 方法. 默认使用 Object.assign 浅合并，可手动调用传参深度合并.)\r\n      lazyPeriod : ~~(options.lazyPeriod as number) || 5000, // set the lazy period of lazySave methods.\r\n      saveMutex: true, // 存储互斥 仅在 idle 状态可进行保存操作\r\n      autoLazy: true, // Call lazy save automaticly when the save is busy. \r\n      logEvent: false, // use this to log event globally from scratch\r\n      useSharedCabinet: true, // use global shared cabinet\r\n      shareCabinet: true, // share the cabinet for global\r\n      // Weather use deepAssign to contact when load the outer data.\r\n      // (If the observer is required, it is recommend you to always keep this on to prevent reference loss.)\r\n      deepMerge: false, \r\n      // local interfaces of storage\r\n      localInterface: {\r\n        database: window.localStorage,\r\n        getItem: \"getItem\", // method name, String\r\n        setItem: \"setItem\", // method name, String\r\n        removeItem: \"removeItem\", // method name, String\r\n      }, \r\n      \r\n      // Decide weather enable local cabinet when cloud is setted. Auto judge.\r\n      concurrent: !!(options.outerLoad || options.outerSave || options.outerClear),\r\n      // cloud loads example options. The inner pointer `this` is pointed to `cabinet.options` if not set by arrow function.\r\n      outerLoad: null,\r\n      outerSave: null,\r\n      outerClear: null,\r\n    };\r\n    this.options = deepAssign(defaultOptions, options);\r\n    // Make the privilege.\r\n    this.__install(defaultOptions);\r\n    \r\n    // root event console log\r\n    if(defaultOptions.logEvent) this._setlog();\r\n\r\n    this.status = _STATUS.CREATED; // status token\r\n    this._trigger(\"created\");\r\n    \r\n    if(defaultOptions.autoload) this._init(options.initStorage || Object.create(null) );\r\n  };\r\n\r\n  /**\r\n   * Initialize the cabinet storage before 'CURD' manipulation.\r\n   * If autoload is not setted, you should call this manually.\r\n   * Todo: add reduplicate._init check and warning.\r\n   */\r\n  Proto._init = function(cabinet = Object.create(null)){\r\n    // write protection backflow\r\n    const writeBackflow = function(){\r\n      if(is_Empty(this.__tempStorage)) return;\r\n      // backflow\r\n      deepAssign(this.__storage, this.__tempStorage);\r\n      this.__tempStorage = Object.create(null);\r\n      this._trigger(\"writeBackflow\");\r\n    }\r\n    this._on(\"loaded\", writeBackflow);\r\n    this._on(\"cleared\", writeBackflow);\r\n\r\n    // override the options by the already existed cabinet.\r\n    // this is global shared with all the instance in the page.\r\n    const isLoadFromCache = this.options.useSharedCabinet && this.hasStore();\r\n    if(isLoadFromCache){\r\n      // this.__storage = cabinet = this.getStore(); // That's useless cause cabinet is just a Object reference.\r\n      this.__storage = this.getStore();\r\n      // Sync status.\r\n      Object.assign(cabinet, this.__storage);\r\n      this._trigger(\"loadFromCache\");\r\n    }\r\n    else{\r\n      this.__storage = this.__storage || cabinet;\r\n      if(this.options.shareCabinet)\r\n        this.setStore(this.__storage);\r\n    }\r\n\r\n    this.status = _STATUS.MOUNTED;\r\n    this._trigger(\"mounted\"); // Interior cabinet access attainable.\r\n\r\n    if(!isLoadFromCache){\r\n      // Auto load. Only when the cabinet in using is private.\r\n      if(this.options.autoload) this.load(); // default using shallow assign.\r\n      else this.status = _STATUS.IDLE; // Amend the status error.\r\n    }\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Test the cabinet is busy or not.\r\n   */\r\n  Proto.isVacant = function(){\r\n    return this.status===_STATUS.IDLE;\r\n  }\r\n\r\n  /**\r\n   * Set an item with key.\r\n   * Added write protection on stage of loading and clearing.\r\n   * @param {*} key \r\n   * @param {*} value \r\n   */\r\n  Proto.set = function(key, value){\r\n    const MutexStatus = [_STATUS.LOADING, _STATUS.CLEARING];\r\n    // add write protection.    \r\n    if(MutexStatus.indexOf(this.status) > -1){\r\n      this._trigger(\"writeLock\");\r\n      this.__tempStorage = this.__tempStorage || (this.__tempStorage = Object.create(null));\r\n      this.__tempStorage[key] = value;\r\n      return this;\r\n    }\r\n\r\n    this.__storage[key] = value;\r\n    this._trigger('setItem', key, value);\r\n    return this;\r\n  };\r\n\r\n  /**\r\n   * Get the value of an item by key.\r\n   * Please don't read from loading and clearing stream.\r\n   * @param {*} key \r\n   */\r\n  Proto.get = function(key){\r\n    let backValue = this.__storage[key];\r\n    this._trigger('getItem', key, backValue);\r\n    return backValue;\r\n  }\r\n\r\n  /**\r\n   * Delete an item by key.\r\n   */ \r\n  Proto.remove = function(keys){\r\n    let removed = false;\r\n    arbitraryFree(keys, (k)=>{\r\n      // Though it isn't disappeared immediately, But after JSON parse and stringify manipulations this will be cleared.\r\n      if(this.__storage.hasOwnProperty(k)){\r\n        this.set(k, void 0);\r\n        removed = true\r\n      }\r\n    }); \r\n    removed && this._trigger('removeItem', keys, removed);\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Delete the cabinet directly.\r\n   * But the data may still exist in memory(RAM).  \r\n   * @param {Boolean} onCloud \r\n   * @param {Boolean} concurrent Override the default options in `this.options.concurrent`\r\n   */\r\n  Proto.clear = function(option: AccessOptions = {}){\r\n    // merge default options.\r\n    const concurrent = is_Defined(option.concurrent)? option.concurrent: this.options.concurrent;\r\n    const onCloud = (is_Defined(option.onCloud)? option.onCloud: !!this.options.outerClear) as boolean;\r\n    this.status = _STATUS.LOADING;\r\n    this._trigger('beforeClear');\r\n    \r\n    // Local clear\r\n    let localClear = ()=>{\r\n      const IgnoreLocal = onCloud && !concurrent;\r\n      this._trigger('beforeLocalClear', IgnoreLocal); // give an status token before invoke.\r\n\r\n      if(IgnoreLocal){\r\n        DEBUG && console.log(`${LogToken}The local clear action is ignored by options: concurrent:false.`);\r\n        return this;\r\n      }\r\n      const localApi = this.options.localInterface;\r\n      localApi.database[localApi.removeItem]( this.__root );\r\n      // trigger hook event after call local database to clear the Item.\r\n      this._trigger('localCleared', this.__root); // Give the param of the remove target. \r\n    }\r\n\r\n    // Cloud clear\r\n    const pack = [this.__root, this.__storage];\r\n    const onSuccess = ()=>{\r\n      this.status = _STATUS.IDLE;\r\n      this._trigger('cleared', onCloud, concurrent);\r\n      // Callback\r\n      option.onceDone && option.onceDone(true, onCloud);\r\n    }\r\n    const onError = (msg, reason='cloudClearings')=>{\r\n      this._trigger(\"error\", \"clear\", reason);\r\n      this.status = _STATUS.IDLE;\r\n      this._trigger('cleared', onCloud, concurrent);\r\n      onCloud && console.error(`${LogToken}Failed to Clear the cabinet \"${this.__root}\" on cloud. ${msg}`);\r\n      // Callback\r\n      option.onceDone && option.onceDone(false, onCloud);\r\n    }\r\n\r\n    // handle this async or asyn easily.\r\n    try{\r\n      localClear();\r\n      if(onCloud) \r\n        this.options.outerClear(pack, onSuccess, onError);\r\n      else {\r\n        this.status = _STATUS.IDLE;\r\n        this._trigger('cleared', onCloud, concurrent);\r\n        // Callback\r\n        option.onceDone && option.onceDone(true, onCloud);\r\n      }\r\n    } catch(e){\r\n      onError(e, \"unknown\");\r\n    }\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Load the cabinet on initialization.\r\n   * The local load is faster than cloud.\r\n   * @param { Boolean } onCloud \r\n   * @param { Boolean } concurrent Override the default options in `this.options.concurrent`\r\n   * @param { Boolean } deepMerge Using deepAssign instead of Object.assign to merge the data from local and cloud.\r\n   */\r\n  Proto.load = function(option: AccessOptions = {}){\r\n    // merge default options.\r\n    const concurrent = is_Defined(option.concurrent)? option.concurrent: this.options.concurrent;\r\n    const onCloud = (is_Defined(option.onCloud)? option.onCloud: !!this.options.outerLoad) as boolean;\r\n    const deepMerge = is_Defined(option.deepMerge)? ~~(option.deepMerge as Boolean): this.options.deepMerge;\r\n    this.status = _STATUS.LOADING;\r\n    this._trigger(\"beforeLoad\");\r\n\r\n    // Local load \r\n    let localLoad = ()=>{\r\n      let localTemp = null;\r\n      const IgnoreLocal = onCloud && !concurrent;\r\n      this._trigger('beforeLocalLoad', IgnoreLocal); // give an status token before invoke.\r\n\r\n      if(IgnoreLocal){\r\n        DEBUG && console.log(\"${LogToken}The local load action is ignored by options: concurrent=false.\");\r\n        return this;\r\n      }\r\n      const localApi = this.options.localInterface;\r\n      \r\n      let initialData = localApi.database[localApi.getItem]( this.__root );\r\n      // trigger hook event after call local database to parse the value. Should have a return value in event. (data)=>{ return handle(data); }\r\n      initialData = this._trigger('localLoaded', initialData); // Only take effect on the last element.\r\n\r\n      localTemp = JSON.parse( initialData );\r\n      if(deepMerge)\r\n        deepAssign(this.__storage, localTemp);\r\n      else\r\n        Object.assign(this.__storage, localTemp);\r\n    };\r\n\r\n    // Cloud load\r\n    const pack = [this.__root, this.__storage];\r\n    const onSuccess = (data)=>{\r\n      if(!is_Defined(data) || !is_PlainObject(data))\r\n        throw new Error(`${LogToken}Load cabinet with empty 'data' which type is ${typeof data}`);\r\n        \r\n      if(deepMerge)\r\n        deepAssign(this.__storage, data);\r\n      else \r\n      // shallow assign makes cloud weight heavier.\r\n        Object.assign(this.__storage, data);\r\n      this.status = _STATUS.IDLE;\r\n      this._trigger('loaded', onCloud, concurrent);\r\n      // Callback\r\n      option.onceDone && option.onceDone(true, onCloud);\r\n    }\r\n    const onError = (msg, reason='cloudLoadings')=>{\r\n      this._trigger(\"error\", \"load\", reason);\r\n      this.status = _STATUS.IDLE;\r\n      this._trigger('loaded', onCloud, concurrent);\r\n      onCloud && console.error(`${LogToken}Failed to Load the cabinet \"${this.__root}\" on cloud. ${msg}`);\r\n      // Callback\r\n      option.onceDone && option.onceDone(false, onCloud);\r\n    }\r\n\r\n    // handle this async or asyn easily.\r\n    try{\r\n      localLoad();\r\n      if(onCloud) \r\n        this.options.outerLoad(pack, onSuccess, onError);\r\n      else {\r\n        this.status = _STATUS.IDLE;\r\n        this._trigger('loaded', onCloud, concurrent);\r\n        // Callback\r\n        option.onceDone && option.onceDone(true, onCloud);\r\n      }\r\n    } catch(e){\r\n      onError(e, \"unknown\");\r\n    }\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Save the cabinet to database or cloud.\r\n   * The event `localSaved` is called before real action for storage hook.\r\n   * @param {*} onCloud \r\n   * @param {Boolean} concurrent Override the default options in `this.options.concurrent`\r\n   */\r\n  Proto.save = function(option: AccessOptions = {}){\r\n    // merge default options.\r\n    const onCloud = (is_Defined(option.onCloud)? option.onCloud: !!this.options.outerSave) as boolean;\r\n    const concurrent = is_Defined(option.concurrent)? option.concurrent: this.options.concurrent;\r\n\r\n    // check the status for mutex protection\r\n    let check = this.options.saveMutex && !this.isVacant();\r\n    this._trigger(\"beforeSave\", check);\r\n    if( check ){\r\n      DEBUG && console.log(`${LogToken}The 'save' manipulation is deserted for busy. Current Status: ${this.status} .Set 'saveMutex' false to disable it.`);\r\n      this._trigger(\"busy\", this.status);\r\n      this.options.autoLazy && this.lazySave(onCloud, concurrent);\r\n      return this;\r\n    }\r\n    \r\n    this.status = _STATUS.SAVING;\r\n\r\n    // Local save \r\n    let localSave = ()=>{\r\n      const IgnoreLocal = onCloud && !concurrent;\r\n      this._trigger('beforeLocalSave', IgnoreLocal); // give an status token before invoke.\r\n\r\n      if(IgnoreLocal){\r\n        DEBUG && console.log(\"${LogToken}The local save action is ignored by options: concurrent=false.\");\r\n        return this;\r\n      }\r\n      // trigger hook event beforeLocalSave. Should have a return value in event. (data)=>{ return handle(data); }\r\n      let finalData = JSON.stringify(this.__storage );\r\n      // trigger hook event before call local database to save the value for data interceptor.\r\n      finalData = this._trigger('localSaved', finalData); // Only take effect on the last element.\r\n\r\n      const localApi = this.options.localInterface;\r\n      localApi.database[localApi.setItem](this.__root, finalData);\r\n    };\r\n    \r\n\r\n    // Cloud save\r\n    const pack = [this.__root, this.__storage];\r\n    const onSuccess = ()=>{\r\n      this.status = _STATUS.IDLE;\r\n      this._trigger('saved', onCloud, concurrent);\r\n      // Callback\r\n      option.onceDone && option.onceDone(true, onCloud);\r\n    }\r\n    const onError = (msg, reason=\"cloudSavings\")=>{\r\n      this._trigger(\"error\", \"save\", reason);\r\n      this.status = _STATUS.IDLE;\r\n      this._trigger('saved', onCloud, concurrent);\r\n      onCloud && console.error(`${LogToken}Failed to Save the cabinet \"${this.__root}\" on cloud. ${msg}`);\r\n      // Callback\r\n      option.onceDone && option.onceDone(false, onCloud);\r\n    }\r\n\r\n    // handle this async or asyn easily.\r\n    try{\r\n      localSave();\r\n      if(onCloud) \r\n        this.options.outerSave(pack, onSuccess, onError);\r\n      else {\r\n        this.status = _STATUS.IDLE;\r\n        this._trigger('saved', onCloud, concurrent);\r\n        // Callback\r\n        option.onceDone && option.onceDone(true, onCloud);\r\n      }\r\n    } catch(e){\r\n      onError(e, 'unknown');\r\n    }\r\n    return this;\r\n  }\r\n  \r\n  /**\r\n   * Map methods support.\r\n   * Iterate the first hierarchy with callback.\r\n   * @param {Function: (item, index)=>any }} callback with two params\r\n   */\r\n  Proto.forEach = function(callback){\r\n    let item, index = 0;\r\n    const cabinet = this.__storage;\r\n    for(let key in cabinet){\r\n      item = cabinet[key];\r\n      callback(item, index++, cabinet); // only two params.\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Foreach methods support.\r\n   * Iterate the first hierarchy with callback.\r\n   * @param {Function: (item, index)=>any }} callback  with two params\r\n   */\r\n  Proto.map = function(callback){\r\n    let item;\r\n    const cabinet = this.__storage;\r\n    for(let key in cabinet){\r\n      item = cabinet[key];\r\n      cabinet[key] = callback(item, key, cabinet); // only two params.\r\n    }\r\n  }\r\n\r\n  /**\r\n   * For custom destroy.\r\n   * Call it to clear the sideEffect produce by kinds of plugins.\r\n   */\r\n  Proto.destroy = function(){\r\n    this._trigger(\"destroied\");\r\n  }\r\n\r\n}\r\n","import { DEBUG } from \"@/utils/util\";\r\n\r\n/**\r\n * Lazy methods support.\r\n * @param {*} Lycabinet \r\n */\r\nexport function InitLazyDepartment(Lycabinet){\r\n  \r\n  /**\r\n   * Add lazySave support.\r\n   * The params is the same to save methods.\r\n   */\r\n  Lycabinet.prototype.lazySave = (function(){\r\n    var lastTime = 0;\r\n    return function(...params){\r\n      var nowTime = new Date().getTime();\r\n      // The gap is not so accurate but enough.\r\n      let judge = nowTime - lastTime > 5000; //this.options.lazyPeriod;\r\n      this._trigger(\"lazySave\", judge);\r\n      if (judge) {\r\n        lastTime = nowTime; // first!\r\n        // Use default settings\r\n        DEBUG && console.log(\"Lazy executed!\", nowTime, lastTime, judge)\r\n        this.save(...params);\r\n      }\r\n      return this;\r\n    }\r\n  })();\r\n\r\n  /**\r\n   * Just calling lazySave after save called.\r\n   * @param {*} key \r\n   * @param {*} value \r\n   * @param {...any} params parameters to lazySave (). \r\n   */\r\n  Lycabinet.prototype.lazySet = function(key, value, ...params){\r\n    this.set(key, value).lazySave(...params);\r\n    return this;\r\n  }\r\n}","/**\r\n * 提供接口利用 laction 作为支持, 影响后续所有实例\r\n * 利用Laction 进行 lazySave 性能进一步优化和增强为节流防抖双支持模式.\r\n * \r\n * // Usage:\r\n * import Lycabinet\r\n * // Existed instance of Laction\r\n * lactionIns.use(Lycabinet);\r\n * \r\n * When enabled immbedding, you should manually call the `destroy` method\r\n *  to discard the instance(Especially there is not only one).\r\n */\r\n\r\nimport { DEBUG, deepSupplement } from \"../utils/util\";\r\n\r\nexport function initImbedding(Lycabinet){\r\n  // Provide as a Laction plugins.\r\n  Lycabinet.install = function(lactionIns, options){\r\n    // Add mixin. Should be called before lycabinet instantiation.\r\n    Lycabinet.mixin(function(lycabinetIns){\r\n      // add some actions for laction conjunction.\r\n      deepSupplement(lycabinetIns.options, {\r\n        useLaction:{\r\n          // the target orbit of bubbled lazy message \r\n          lazyOrbitId: -1, // the last orbit. see: https://github.com/lozyue/laction.git\r\n        }\r\n      });\r\n\r\n      let LazyRootKey = lycabinetIns.__root+'_lazy';\r\n      // Accept pre-redundant postfix.\r\n      const LazyKey = lactionIns.testHookName(LazyRootKey, true);\r\n      lycabinetIns.getLazyKey = ()=>LazyKey;\r\n      lycabinetIns._lazyKey = LazyKey;\r\n\r\n      // Register the lazy methods hook.\r\n      lactionIns.registerHook(\r\n        {\r\n          name: LazyKey,\r\n          // apply period throttle.s\r\n          once: true, \r\n          // apply period debounce.\r\n          debounce: true, \r\n          // level: 3, // 1 Root 消息级钩子 // 默认普通消息\r\n          action: (...params)=>{\r\n            // Find a big question of save action rewrite with laction if there are multi-instances.\r\n            // console.log(lycabinetIns)\r\n            \r\n            lycabinetIns.save(...params) \r\n          },\r\n        },\r\n      );\r\n\r\n      lycabinetIns._on(\"destroied\", ()=>{\r\n        lactionIns.unregisterHook(LazyKey);\r\n      });\r\n    });\r\n\r\n    /**\r\n     * lazySave method update\r\n     * OverWrite lazy methods with laction instances. \r\n     *  And give it better performance and even visualizaztion.\r\n     * @param {*} lazyOrbitId the added params for laction. \r\n     */\r\n    Lycabinet.prototype.lazySave = function(...params){\r\n      // Get the key of Auto generated.\r\n      params.unshift( this._lazyKey );\r\n      // bubble with auto period throttle and debounce.\r\n      \r\n      lactionIns.bubble(params, this.options.useLaction.lazyOrbitId, false);\r\n      this._trigger(\"lazySave\");\r\n      return this;\r\n    };\r\n  };\r\n}\r\n","/**\r\n * Add alias to some methods.\r\n * To custom the using habit for general users.\r\n */\r\n\r\nexport function initAlias(Lycabinet){\r\n  const Proto = Lycabinet.prototype;\r\n  \r\n  Proto.delete = Proto.remove;\r\n\r\n  Proto.read = Proto.get;\r\n\r\n  Proto.storage = Proto.getStore;\r\n\r\n  Proto.getCabinet = Proto.getStore;\r\n}","/**\r\n * Add a filter before save the storage.\r\n * You should give a value to the options : includes & excludes.\r\n * (Via to JSON hook)\r\n * @param {*} Lycabinet \r\n */\r\nimport { DEBUG, deepSupplement, is_Defined } from '../utils/util';\r\n\r\nexport function addFilter(Lycabinet){\r\n  /**\r\n   * Set a filter by options\r\n   * Support dot `.` selection expression\r\n   * @param {Object} cabinetIns {includes: [], excludes:[] }\r\n   */\r\n  Lycabinet.mixin(function(cabinetIns){\r\n    const opt = cabinetIns.options;\r\n    if(opt.includes && opt.excludes)\r\n      this.setFilter(); // auto set.\r\n    else{\r\n      deepSupplement(opt, {\r\n        includes: [], // vacant equals to all!\r\n        excludes: [], // vacant equals to none.\r\n      });\r\n    }\r\n  });\r\n\r\n  Lycabinet.prototype.setFilter = function (){\r\n    const _this = this;\r\n    Object.defineProperty(this.getStore(), 'toJSON', {\r\n      configurable: true,\r\n      enumerable: false, // hide in enumeration.\r\n      value: function(){\r\n        let filtered = Object.create(null);\r\n        // set the basement includes.\r\n        if(_this.options.includes.length>0){\r\n          let includesKeyMap: number[]= [];\r\n          _this.options.includes.forEach( (associatedKey,index)=>{\r\n            let current = includesKeyMap[index] = associatedKey.split(\".\");\r\n            let currentStorage = _this.__storage;\r\n            current.forEach((item, i )=>{\r\n              currentStorage = currentStorage[current[i]];\r\n              // Compliment the non-final selection. \r\n              if( i +1 < current.length && is_Defined( currentStorage )){\r\n                if(!is_Defined(filtered[current[ i ]]) )\r\n                  filtered[current[i]] = {};\r\n                else\r\n                  Object.assign(filtered[current[i]], currentStorage);\r\n              }else\r\n                filtered[current[i]] = currentStorage;\r\n            });\r\n          });\r\n        // if the configuration of `includes` option is not designed, it will mean exactly includes all by default. \r\n        }else Object.assign(filtered, _this.__storage);\r\n        // caculating the exclude filtering.\r\n        let excludesKeyMap: Array<number>= [];\r\n        _this.options.excludes.forEach( (associatedKey, index, arr)=>{\r\n          let current = excludesKeyMap[index] = associatedKey.split(\".\");\r\n          let currentStorage = filtered;\r\n          // instead of forEach for better logical control.\r\n          for(let i=0; i<current.length; i++){\r\n            if(!is_Defined(filtered[current[0]]) ) break;\r\n\r\n            if(is_Defined(currentStorage[current[i]]) )\r\n              currentStorage = currentStorage[current[i]];\r\n            else\r\n              break ;\r\n            // find the target.\r\n            if(i === arr.length-1)\r\n              currentStorage = void 0;\r\n          };\r\n        });\r\n        return filtered;\r\n      },\r\n    });\r\n  }\r\n}","/**\r\n * Using a preset dictionary to compress the json data for storage or transfer. \r\n */\r\n\r\nimport { arrayIndex } from \"../utils/util\";\r\n\r\nexport function addZip(Lycabinet){\r\n  Lycabinet.mixin(function(cabinetIns){\r\n    cabinetIns._on(\"localLoaded\", function(finalData, results){\r\n      let final = results.length? arrayIndex(results, -1): finalData;\r\n      // todo...\r\n      // console.log(`beforeLocalLoad: length:${final.length}`, final, final.replaceAll(`'`, `.`));\r\n      return final;\r\n    });\r\n    cabinetIns._on(\"localSaved\", function(finalData, results){\r\n      let final = results.length? arrayIndex(results, -1): finalData;\r\n      // todo...\r\n      // console.log(`beforeLocalSave: length:${final.length}`, final, final.replaceAll(`.`, `'`));\r\n      return final;\r\n    });\r\n  });\r\n}\r\n"],"names":["root","factory","exports","module","define","amd","self","__webpack_require__","definition","key","o","Object","defineProperty","enumerable","get","obj","prop","prototype","hasOwnProperty","call","arrayIndex","arr","index","undefined","length","Error","toString","curveGet","source","objPathes","interim","item","addStoreListener","invokeQueue","window","addEventListener","eve","forEach","func","invoke","remove","removeArrayItem","push","deepAssign","objs","merged","reduce","target","is_PlainObject","deepSupplement","supplement","current","is_Defined","v","is_Function","Function","indexOf","splice","LogToken","IDLE","LOADING","onSetted","deepConvert","deepWatch","shallowWatch","plainObjQueue","iterate","unshift","ref","convert","internalValue","create","_parent","triggers","value","propConfig","configurable","writable","$addListener","onchange","$removeListener","handle","AccessQueue","hook","refValue","Proxy","receiver","set","newValue","rawValue","ParticalToken","Lycabinet","options","this","__init","apply","__cabinet","hasStore","__root","getStore","setStore","cabinet","removeStore","$removeStore","InitStore","_mixins","mixin","mixinFunc","__install","InitMixin","preOwnner","subscriptions","_on","name","_off","actions","_trigger","params","results","temp","counter","_once","instantOnTriggered","subs","handleFunc","_isHappend","_setlog","DEBUG","Set","keys","concat","testHandle","_logHandle","logHandle","console","log","SeparateLog","InitEventSystem","Proto","initStorage","str","constructor","String","defaultOptions","autoload","lazyPeriod","saveMutex","autoLazy","logEvent","useSharedCabinet","shareCabinet","deepMerge","localInterface","database","localStorage","getItem","setItem","removeItem","concurrent","outerLoad","outerSave","outerClear","status","_init","writeBackflow","val","__tempStorage","Array","isArray","slice","__storage","isLoadFromCache","assign","load","isVacant","backValue","removed","input","k","clear","option","onCloud","localClear","IgnoreLocal","localApi","pack","onSuccess","onceDone","onError","msg","reason","error","e","localLoad","localTemp","initialData","JSON","parse","data","save","check","lazySave","localSave","finalData","stringify","callback","map","destroy","InitCore","lastTime","nowTime","Date","getTime","judge","lazySet","InitLazyDepartment","install","lactionIns","lycabinetIns","useLaction","lazyOrbitId","LazyRootKey","LazyKey","testHookName","getLazyKey","_lazyKey","registerHook","once","debounce","action","unregisterHook","bubble","initImbedding","delete","read","storage","getCabinet","initAlias","cabinetIns","opt","includes","excludes","setFilter","_this","filtered","includesKeyMap","associatedKey","split","currentStorage","i","excludesKeyMap","addFilter","initObserver","lazy","initWatch","$set","pathList","deep","shallow","curveSet","innerTarget","kname","$get","pathName","addObserver","final","_dirty","localContext","useLoadCache","objectSupplement","autoNotifyTabs","sessionStorage","notifyTabs","randomToken","addCheck","addZip"],"sourceRoot":""}