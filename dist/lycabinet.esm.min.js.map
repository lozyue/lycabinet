{"version":3,"file":"lycabinet.esm.min.js","mappings":"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","sources":["webpack://Lycabinet/webpack/bootstrap","webpack://Lycabinet/webpack/runtime/define property getters","webpack://Lycabinet/webpack/runtime/hasOwnProperty shorthand","webpack://Lycabinet/./src/utils/util.ts","webpack://Lycabinet/./src/extends/filter.ts","webpack://Lycabinet/./src/extends/observer.ts","webpack://Lycabinet/./src/index.ts","webpack://Lycabinet/./src/core/mixin.ts","webpack://Lycabinet/./src/core/event.ts","webpack://Lycabinet/./src/core/store.ts","webpack://Lycabinet/./src/core/lycabinet.ts","webpack://Lycabinet/./src/utils/status.ts","webpack://Lycabinet/./src/core/lazy-support.ts","webpack://Lycabinet/./src/core/immbedding.ts","webpack://Lycabinet/./src/extends/alias.ts","webpack://Lycabinet/./src/extends/check.ts","webpack://Lycabinet/./src/extends/zip.ts"],"sourcesContent":["// The require scope\nvar __webpack_require__ = {};\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","/**\r\n * Utils.js.\r\n * By lozyue.\r\n */\r\n\r\n/**\r\n * Get the item in an array with index. Support negative index.\r\n * @param  {...any} objs \r\n */\r\nexport const arrayIndex = function (arr, index) {\r\n  index = (arr.length + index) % arr.length;\r\n  if (arr[index] === undefined) {\r\n    DEBUG&& console.error(`The index ${index} in array ${arr.toString()} is overflowed!`);\r\n  }\r\n  return arr[index];\r\n}\r\n\r\n/**\r\n * Get the target curve path value of the source Object.\r\n * The curve path is a sequenced array\r\n * @param source \r\n * @param objPathes \r\n */\r\nexport function curveGet(source: Object, objPathes: string[]){\r\n  let interim = source, item = '';\r\n  for(let index=0; index<objPathes.length; index++){\r\n    item = objPathes[index];\r\n    interim = interim && interim[item]\r\n    if(interim === void 0 ){\r\n      return void 0;\r\n    };\r\n  }\r\n  return interim;\r\n}\r\n\r\n/**\r\n * Set the consistent even curve path of the source Object \r\n * The curve path is a sequenced array // dot split strings.\r\n * @param source \r\n * @param objPathes \r\n * @param {unknown|Function} value The value assign for the curve object target. Support callback that if target value is a function you should set it in call back.\r\n * @returns { number|true } The number indicator the failed position of the conflict path.\r\n */\r\n export function curveSet(source: Object, objPathes: string[], value: ((target: Object, name: string)=>any)| unknown= null){\r\n  let interim = source, item = '';\r\n  // not the last one.\r\n  let index=0;\r\n  for(; index<objPathes.length-1; index++){\r\n    item = objPathes[index];\r\n    if(is_Defined(interim[item]) ){\r\n      if(is_Object(interim[item])){\r\n        interim = interim[item];\r\n      } else {\r\n        // Unexpected non-object value.\r\n        return index;\r\n      }\r\n    } else \r\n      interim = interim[item] = {};\r\n  };\r\n  // the last\r\n  item = objPathes[index];\r\n  // assign the value.\r\n  if(is_Function(value))\r\n    (value as Function)(interim, item);\r\n  else\r\n    interim[item] = value;\r\n  return true;\r\n}\r\n\r\n/**\r\n * Centralized management.\r\n * Add a listener to window storage event.\r\n * @param { Function } invoke Target invoke function or handle. \r\n * @param { Boolean } remove wheather the action is to remove added storage listener.\r\n */\r\nexport const addStoreListener = (()=>{\r\n  const invokeQueue: Function[]= [];\r\n  window.addEventListener(\"storage\", (eve)=>{\r\n    invokeQueue.forEach(func=>{\r\n      func(eve);\r\n    });\r\n  }, false); // default bubble.\r\n\r\n  return (invoke, remove = false)=>{\r\n    if(remove) \r\n      removeArrayItem(invokeQueue, invoke);\r\n    else invokeQueue.push(invoke);\r\n  }\r\n})();\r\n\r\n/**\r\n * Deep Object.assign source to target.\r\n * @param { null|Object, Object... }...objs\r\n */\r\nexport const deepAssign = function (...objs) {\r\n  let merged;\r\n  objs.reduce((target, source) => {\r\n    for (let item in source) {\r\n      if (!(target[item] && is_PlainObject(target[item])) ) {\r\n        target[item] = source[item];\r\n      } else {\r\n        deepAssign(target[item], source[item]);\r\n      }\r\n    }\r\n    merged = target;\r\n    return target;\r\n  }, objs[0]); // The third param is to set default value.\r\n  return merged;\r\n}\r\n\r\n/**\r\n * Deep Object.assign source to target.\r\n * @param target\r\n * @param source\r\n * @param condition Receive the to contacted source and target value and returns the custom result.\r\n */\r\nexport const deepConditionalAssign = function (source, target, condition:null|Function=null ) {\r\n  for (let item in target) {\r\n    if (!(source[item] && is_PlainObject(source[item])) ) {\r\n      // The source Item won't be PlainObject or FalseValue.\r\n      if(!condition)\r\n        source[item] = target[item];\r\n      else\r\n        source[item] = condition(source[item], target[item]);\r\n    } else {\r\n      deepConditionalAssign(source[item], target[item]);\r\n    }\r\n  }\r\n  return source;\r\n}\r\n\r\n/**\r\n * Just assign the item in supplement which not defined in target.\r\n * If you don't want to override the value of origin Object, supplement is the high performance choice.\r\n * Not deep mode.\r\n * @param {*} target \r\n * @param {*} supplement \r\n */\r\nexport function objectSupplement(target, supplement) {\r\n  let current = null;\r\n  for (let item in supplement) {\r\n    current = target[item];\r\n    if (is_Defined(current))\r\n      continue;\r\n    target[item] = supplement[item];\r\n  }\r\n  return target;\r\n}\r\n\r\n/**\r\n * Just assign the item in supplement which not defined in target.\r\n * If you don't want to override the value of origin Object, supplement is the high performance choice.\r\n * Deep mode by iterate each inner Object.\r\n * @param {*} target \r\n * @param {*} supplement \r\n */\r\nexport function deepSupplement<R extends Object, T extends Object> (target: R|null, supplement: T) {\r\n  if(!target) return supplement;\r\n  let current: unknown = null;\r\n  for (let item in supplement) {\r\n    current = (target as unknown as T)[item];\r\n    if (is_Defined(current)) {\r\n      if (!is_PlainObject(current as Object)) continue;\r\n      deepSupplement(current as Object, supplement[item]); // The `current` is a reference which could be assigned.\r\n    }\r\n    else\r\n      // current = supplement[item];\r\n      (target as unknown as T)[item] = supplement[item];\r\n  }\r\n  return target as (R & T);\r\n}\r\n\r\n\r\n/**\r\n * Simple deepClone with optional Function clone\r\n */\r\nexport function deepClone(val, substituteObj = Object.create(null), cloneFunc = true) {\r\n  if (is_PlainObject(val)) {\r\n    var res = substituteObj;\r\n    for (var key in val) {\r\n      res[key] = deepClone(val[key]);\r\n    }\r\n    return res;\r\n  } else if (is_Array(val)) {\r\n    return val.slice()\r\n  } else if (cloneFunc && is_Function(val)) {\r\n    return Object.create(val.prototype).constructor;\r\n  } else {\r\n    return val;\r\n  }\r\n}\r\n\r\nexport function iterateObject(source: Object, iterate: Function){\r\n  iterate(source);\r\n  for(let item in source){\r\n    if( is_PlainObject(source[item]) )\r\n      iterate(source, iterate);\r\n  }\r\n}\r\n\r\nexport const is_Defined = (v: unknown):Boolean => (v !== undefined && v !== null);\r\nexport const is_Object = (obj: unknown):Boolean => (obj instanceof Object || typeof obj === \"object\");\r\nexport const is_PlainObject = (obj: unknown):Boolean => (Object.prototype.toString.call(obj) === '[object Object]');\r\nexport const is_Array = (obj: unknown):Boolean => (Array.isArray && Array.isArray(obj) || obj instanceof Array || (typeof obj === 'object') && Object.prototype.toString.call(obj).slice(-6,-1)=== 'Array' );\r\nexport const is_String = (str: Object):Boolean => ((typeof str === 'string') && str.constructor == String);\r\nexport const is_Function = (obj: unknown):Boolean => (obj instanceof Function);\r\n\r\nexport const is_Empty = (val: unknown)=>{\r\n  if(!val) return true;\r\n  if(is_Array(val)){\r\n    return !(val as Array<unknown>).length;\r\n  }else{\r\n    return !Object.keys((val) as Object).length;\r\n  }\r\n}\r\n\r\n/*\r\n * Delete the Item in an Array, returning the new Array.\r\n */\r\nexport var removeArrayItem = (arr, item) => {\r\n  if (arr.length) {\r\n    let index = arr.indexOf(item);\r\n    if (index > -1) {\r\n      return arr.splice(index, 1);\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n * Provide with a processor accept a list of stuff or single stuff\r\n * Give it the action to its inner iterator.\r\n * The original Stuff can not be an Array!\r\n */\r\nexport function arbitraryFree(input, func) {\r\n  if (input.forEach) {\r\n    return input.forEach(func);\r\n  } else {\r\n    return func(input, 0);\r\n  }\r\n}\r\n\r\nexport function storageAvailable(type) {\r\n  var storage;\r\n  try {\r\n    storage = window[type];\r\n    var x = '__storage_test__';\r\n    storage.setItem(x, x);\r\n    storage.removeArrayItem(x);\r\n    return true;\r\n  }\r\n  catch (e) {\r\n    return e instanceof DOMException && (\r\n      // everything except Firefox\r\n      e.code === 22 ||\r\n      // Firefox\r\n      e.code === 1014 ||\r\n      // test name field too, because code might not be present\r\n      // everything except Firefox\r\n      e.name === 'QuotaExceededError' ||\r\n      // Firefox\r\n      e.name === 'NS_ERROR_DOM_QUOTA_REACHED') &&\r\n      // acknowledge QuotaExceededError only if there's something already stored\r\n      (storage && storage.length !== 0);\r\n  }\r\n}\r\n\r\nexport const LogToken = \"[Lycabinet]: \";\r\n\r\nexport const DEBUG = process.env.NODE_ENV !== 'production';\r\n\r\nexport const EnvAssociate = {\r\n  Light: false, // light mode.\r\n};\r\n","/**\r\n * Add a filter before save the storage.\r\n * You should give a value to the options : includes & excludes.\r\n * (Via to JSON hook)\r\n * @param {*} Lycabinet \r\n */\r\nimport { DEBUG, deepClone, deepSupplement, is_Defined } from '../utils/util';\r\n\r\nexport function addFilter(Lycabinet){\r\n  const Proto = Lycabinet.prototype;\r\n  /**\r\n   * Set a filter by options\r\n   * Support dot `.` selection expression\r\n   * @param {Object} cabinetIns {includes: [], excludes:[] }\r\n   */\r\n  Lycabinet.mixin(function(cabinetIns){\r\n    const opt = cabinetIns.options;\r\n    if(opt.includes || opt.excludes){\r\n      cabinetIns._ready(\"mounted\", ()=>{\r\n        cabinetIns.setFilter(); // auto set.\r\n      });\r\n    }\r\n    deepSupplement(opt, {\r\n      includes: [], // vacant equals to all!\r\n      excludes: [], // vacant equals to none.\r\n    });\r\n  });\r\n\r\n  Proto.setFilter = function(){\r\n    const _this = this;\r\n\r\n    Object.defineProperty(this.getCabinet(), 'toJSON', {\r\n      configurable: true,\r\n      enumerable: false, // hide in enumeration.\r\n      value: function(){\r\n        const cabinet = _this.getCabinet();\r\n        // set the basement includes.\r\n        const Includes = _this.options.includes;\r\n        const Excludes = _this.options.excludes;\r\n        return CustomFilter(cabinet, Includes, Excludes);\r\n      },\r\n    });\r\n  };\r\n\r\n  /**\r\n   * Allow you appointed the specific Storage Object and \r\n   *  temporary Includes/Excludes options.\r\n   */\r\n  Lycabinet.$filter = CustomFilter;\r\n}\r\n\r\n/**\r\n * Helper Function.\r\n */\r\nfunction CustomFilter(cabinet, Includes, Excludes){\r\n  let filtered = Object.create(null);\r\n  if(Includes.length>0){\r\n    let includesKeyMap: number[]= [];\r\n    Includes.forEach( (associatedKey,index)=>{\r\n      let current = includesKeyMap[index] = associatedKey.split(\".\");\r\n      let currentStore = cabinet;\r\n      let targetStore = filtered;\r\n      current.forEach((item, i )=>{\r\n        currentStore = currentStore[item];\r\n        // Compliment the non-final selection. \r\n        if( i +1 < current.length && is_Defined( currentStore )){\r\n          if(!is_Defined(targetStore[item]) )\r\n            targetStore[item] = {};\r\n          // else\r\n          //   targetStore[item] = currentStore;\r\n        }else\r\n          targetStore[item] = currentStore;\r\n        targetStore = targetStore[item];\r\n      });\r\n\r\n    });\r\n  // if the configuration of `includes` option is not designed, it will mean exactly includes all by default. \r\n  }else Object.assign(filtered, cabinet);\r\n  // caculating the exclude filtering.\r\n  let excludesKeyMap: Array<number>= [];\r\n  let currentStore = deepClone(filtered);\r\n  Excludes.forEach( (associatedKey, index, arr)=>{\r\n    let current = excludesKeyMap[index] = associatedKey.split(\".\");\r\n    let pointer = currentStore;\r\n    for(let i=0; i<current.length; i++){\r\n      DEBUG && console.log({pointer, current: current[i]});\r\n      \r\n      if(is_Defined(pointer[current[i]]) ){\r\n        // find the target.\r\n        if(i === current.length-1){\r\n          pointer[current[i]] = void 0;\r\n        }\r\n        // continue\r\n        pointer = pointer[current[i]];\r\n      }else\r\n        break ;\r\n    };\r\n  });\r\n  filtered = currentStore;\r\n  return filtered;\r\n}\r\n","/**\r\n * Observer Plugin for Lycabinet\r\n * Adding an mini observer for storage variable listening.\r\n */\r\n\r\nimport { \r\n  curveGet, curveSet, \r\n  removeArrayItem, deepSupplement, is_PlainObject,  \r\n  DEBUG,\r\n  is_Function,\r\n  LogToken\r\n} from \"../utils/util\";\r\n\r\n// change methods.\r\nlet onSetted: Function| null = null;\r\n\r\n/**\r\n * Todo: \r\n *   Support async auto-save when cabinet changes.(Base on Task Queue)\r\n */\r\n\r\nexport function addObserver(Lycabinet){\r\n  const Proto = Lycabinet.prototype;\r\n  Proto.initObserver = function(options: any = {}){\r\n    // Override the default options\r\n    Object.assign(options, {\r\n      deepMerge: true,\r\n    });\r\n    // configurate options\r\n    deepSupplement(options, {\r\n      lazy: true,\r\n      initWatch: true, // whether transform the origin property in Observer.\r\n      deepWatch: true, // whether consistently watch the Object type value setted in initial data.\r\n      shallowWatch: false, // whether just watch the surface of the Object.\r\n    });\r\n\r\n    // init proxy Interceptor.\r\n    onSetted = ()=>{\r\n      // this._trigger(\"setItem\");\r\n      options.lazy? this.lazySave(): this.save();\r\n    };\r\n    \r\n    if(!options.initWatch) return false;\r\n    \r\n    this.__storage = deepConvert(this.__storage, options.deepWatch, options.shallowWatch);\r\n    this.setStore(this.__storage);\r\n  };\r\n\r\n  // Convert the path target to be reactive. Check redundant Prevent by default.\r\n  Lycabinet.$active = function(target: Object, pathList: string[], deep=false, shallow =true){\r\n\r\n    // CurveSet the target value.\r\n    return curveSet(target, pathList, (innerTarget, kname)=>{\r\n      // If target is not existed, set to plain Object; Reset the value if it has been converted.\r\n      if(!is_PlainObject(innerTarget[kname])){\r\n        innerTarget[kname] = {};\r\n      }\r\n      if(DEBUG && innerTarget[kname][\"$addListener\"]){\r\n        console.warn(`${LogToken}The target have been converted before!`, innerTarget[kname]);\r\n      }\r\n      innerTarget[kname] = convert(innerTarget[kname], deep, shallow);\r\n    });\r\n  };\r\n\r\n  /**\r\n   * Makes the target to be reactive\r\n   * If the target path is not defined,\r\n   *  it will be assigned as an Object.\r\n   * Warning: If the value in path end is assigned with non-PlainObject type value previously,\r\n   *  the value will be override by `{}`\r\n   */ \r\n  Proto.$active = function(pathName: string, deep=false, shallow =true){\r\n    return Lycabinet.$active(this.__storage, pathName.split('.'), deep, shallow);\r\n  }\r\n};\r\n\r\n/**\r\n * Proxy Modules.\r\n * @author lozyue\r\n * @time 2021\r\n */\r\n\r\n// Convert the Object and its descendant Object from bottom to top.\r\nfunction deepConvert(source: Object, deepWatch=true, shallowWatch=false){\r\n  const plainObjQueue: Array<any> = [];\r\n  // reverse for convert\r\n  const iterate = (current)=>{\r\n    plainObjQueue.unshift(current);\r\n    for(let item in current){\r\n      if(is_PlainObject(current[item])){\r\n        iterate(current[item]);\r\n      }\r\n    }\r\n  };\r\n  iterate(source);\r\n  plainObjQueue.forEach((item, index, arr)=>{\r\n    for(let ref in item){\r\n      // convert by reference.\r\n      if(is_PlainObject(item[ref]) )\r\n        arr[index][ref] = convert(item[ref], deepWatch, shallowWatch);\r\n    }\r\n  });\r\n  return convert(source, deepWatch, shallowWatch);\r\n}\r\n\r\n/**\r\n * Convert the normal data to be reactive.\r\n *  todo: add the Array type support.\r\n * @param source \r\n * @param deepWatch \r\n * @param shallowWatch \r\n */\r\ntype OnValueChange = (prop:symbol|string, newValue, oldValue)=>unknown;\r\ntype InternalValueType = {\r\n  _parent: null | unknown,\r\n  $addListener: (t:OnValueChange, onProp: string)=>unknown,\r\n  $removeListener: (h:OnValueChange, onProp: string)=>unknown,\r\n  // trigger: Record<string|symbol, OnValueChange[]>,\r\n  triggers: OnValueChange[],\r\n  value: Object,\r\n};\r\nfunction convert(source: Object, deepWatch = false, shallowWatch = true){\r\n  let internalValue: InternalValueType = Object.create(null);\r\n  // to do... Add trigger bubbule to its parents.\r\n  internalValue._parent = null;\r\n  internalValue.triggers = [];\r\n  // save the values\r\n  internalValue.value = source;\r\n  // Config it!\r\n  const propConfig = {\r\n    enumerable: false, // which is not enumerable in source either.\r\n    configurable: true,\r\n    writable: false,\r\n  };\r\n  const $addListener = (onchange: OnValueChange)=>{    \r\n    return internalValue.triggers.push(onchange);\r\n  };\r\n  const $removeListener = (handle: Function)=>{\r\n    return removeArrayItem(internalValue.triggers, handle);\r\n  };\r\n  // Origin Accessable definition\r\n  const AccessQueue = [\"$addListener\", \"$removeListener\"];\r\n  AccessQueue.forEach((hook, index)=>{\r\n    internalValue[hook] = {value: null} as {value: unknown, trigger: Function[]};\r\n    Object.defineProperty(internalValue, hook, {\r\n      value: !index? $addListener: $removeListener,\r\n      ...propConfig\r\n    });\r\n  });\r\n\r\n  const refValue = internalValue.value; // For reader accel.\r\n  const HandleRules = {\r\n    get(target, prop, receiver) {\r\n      DEBUG && console.info(\"Getted\", target, prop, receiver, internalValue);\r\n      if(AccessQueue.indexOf(prop) > -1){\r\n        return internalValue[prop];\r\n      }\r\n      return refValue[prop];\r\n    },\r\n    set(target, prop, newValue, receiver) {\r\n      DEBUG && console.info(\"Setted\", target, prop, receiver, internalValue);\r\n      const rawValue = refValue[prop];\r\n      // consistent deepWatch observer. \r\n      if(deepWatch){\r\n        if(is_PlainObject(newValue)){\r\n          if(shallowWatch){\r\n            refValue[prop] = convert(newValue, false, true);\r\n          }else{\r\n            refValue[prop] = deepConvert(newValue, deepWatch, false);\r\n          }\r\n        }\r\n      }else\r\n        refValue[prop] = newValue;\r\n\r\n      if(newValue !== rawValue){\r\n        let triggers = internalValue.triggers;\r\n        for(let index=0; index< triggers.length; index++){\r\n          // Check it!\r\n          if(!is_Function(triggers[index]) ){\r\n            throw new Error(`The get proxy handler listener added in target is Not a Function which type is ${typeof triggers[index]}`);\r\n          }\r\n          triggers[index](prop, newValue, rawValue);\r\n        }\r\n        if(onSetted!==null) onSetted();\r\n      }\r\n      return true;\r\n    },\r\n  };\r\n  return new Proxy(source, HandleRules);\r\n}\r\n","/**\r\n * Lycabinet JS\r\n * Full build.\r\n */\r\n\r\nimport { InitStore } from './core/store';\r\nimport { InitEventSystem } from './core/event';\r\nimport { InitCore } from './core/lycabinet';\r\nimport { InitLazyDepartment } from './core/lazy-support';\r\nimport { InitMixin } from \"./core/mixin\";\r\n\r\nimport { initImbedding } from './core/immbedding';\r\nimport { initAlias } from './extends/alias';\r\nimport { addFilter } from './extends/filter';\r\nimport { addObserver } from './extends/observer';\r\n\r\nimport { addCheck } from './extends/check';\r\nimport { addZip } from './extends/zip';\r\n\r\n\r\nfunction Lycabinet(...options){\r\n  if (process.env.NODE_ENV !== 'production' && !(this instanceof Lycabinet) ) {\r\n    (console.warn || global && global.warn)('Lycabinet is a constructor and should be called with the `new` keyword');\r\n    return null;\r\n  }\r\n  this.__init.apply(this, options);\r\n}\r\n\r\nInitMixin(Lycabinet);\r\nInitEventSystem(Lycabinet);\r\nInitStore(Lycabinet);\r\nInitCore(Lycabinet);\r\nInitLazyDepartment(Lycabinet);\r\n\r\ninitImbedding(Lycabinet);\r\ninitAlias(Lycabinet);\r\n\r\naddFilter(Lycabinet);\r\naddObserver(Lycabinet);\r\n\r\naddCheck(Lycabinet);\r\naddZip(Lycabinet);\r\n\r\nexport default Lycabinet;\r\n","/**\r\n * Lycabinet Mixin.\r\n */\r\nexport function InitMixin(Lycabinet){\r\n  Lycabinet.prototype._mixins = []; // Shared by instances.\r\n\r\n  Lycabinet.mixin = function (mixinFunc) {\r\n    Lycabinet.prototype._mixins.push(mixinFunc);\r\n    return this;\r\n  };\r\n\r\n  Lycabinet.prototype.__install = function(...options){\r\n    options.unshift(this);\r\n    Lycabinet.prototype._mixins.forEach(func => {\r\n      func.apply(func, options);\r\n    });\r\n  };\r\n}","/**\r\n * Event system provided.\r\n * Have weak hook fundamental at same time.\r\n */\r\nimport { CabinetEventType } from '@/typings/lycabinet';\r\nimport { removeArrayItem, is_Function, DEBUG, arrayIndex, EnvAssociate, is_Defined } from '../utils/util';\r\n\r\nexport function InitEventSystem(Lycabinet){\r\n  let preOwnner = null;\r\n  Lycabinet.mixin(function(_self){\r\n    let subscriptions: Object = null as unknown as Object; \r\n\r\n    if(_self!==preOwnner){\r\n      subscriptions = Object.create(null);\r\n    }\r\n    preOwnner = _self;\r\n\r\n    _self._on = function(name: CabinetEventType, func: Function){\r\n      if(DEBUG &&!is_Function(func)){\r\n        throw new Error(\"[Laction]:The second parameter of _on method must be a callback function!\");\r\n      }\r\n      \r\n      subscriptions||(subscriptions = Object.create(null))\r\n      const actions = subscriptions[name] || (subscriptions[name] = []);\r\n      actions.push(func);\r\n    };\r\n    \r\n    _self._off = function(name: CabinetEventType, handle: Function){\r\n      const actions = subscriptions[name] || (subscriptions[name] = []);\r\n      if(actions._lock===true){\r\n        // Postpone the remove action to nextTick.\r\n        return Promise.resolve().then(()=>{\r\n          return removeArrayItem(actions, handle);\r\n        });\r\n      }\r\n      removeArrayItem(actions, handle);\r\n    };\r\n  \r\n    _self._trigger = function(name: CabinetEventType, ...params){\r\n      const actions = subscriptions[name] || (subscriptions[name] = []);\r\n      // add trigger mark\r\n      if(!actions._counter) actions._counter=0;\r\n      actions._counter++;\r\n      // Add triggering lock protection.\r\n      actions._lock = true;\r\n      \r\n      const results: Array<unknown>= [];\r\n      let preLen = actions.length;\r\n      params.push(results);\r\n      for(let index=0; index<preLen; index++){\r\n        let temp = actions[index].apply(this, params);\r\n        is_Defined(temp) && results.push( temp );\r\n      }\r\n      \r\n      // Unlock the event;\r\n      actions._lock = false;\r\n\r\n      // returns last param if there is no hook. Using the last param to set the default value.\r\n      return results.length>0\r\n        ? arrayIndex(results, -1)\r\n        : params.length>1\r\n          ? arrayIndex(params, -2)\r\n          : null;\r\n    };\r\n  \r\n    _self._ready = function(name: CabinetEventType, func: Function, instantOnTriggered: number|boolean = false){\r\n      const subs = subscriptions[name] || (subscriptions[name] = []);\r\n      if(subs._counter && instantOnTriggered!==false \r\n        && _self._isHappened(name, ~~instantOnTriggered) \r\n      ){\r\n        func(subs._counter);\r\n        return ;\r\n      }\r\n      var handleFunc = function(...params){\r\n        this._off(name, handleFunc);\r\n        func.apply(this, params);\r\n      }; \r\n      this._on(name, handleFunc);\r\n    };\r\n    \r\n    _self._next = function(name: CabinetEventType, func: Function, instantOnTriggered: number|boolean = false){\r\n      const subs = subscriptions[name] || (subscriptions[name] = []);\r\n      var handleFunc = function(...params){\r\n        this._off(name, handleFunc);\r\n        func.apply(this, params);\r\n      }; \r\n      this._on(name, handleFunc);\r\n    };\r\n\r\n    _self._isHappened = function(name: CabinetEventType, counts: number=1){\r\n      const subs = (subscriptions[name] || (subscriptions[name] = []));\r\n      return subs._counter >= counts;\r\n    }\r\n    \r\n    _self._count = function(name: CabinetEventType){\r\n      const subs = (subscriptions[name] || (subscriptions[name] = []));\r\n      return subs._counter;\r\n    }\r\n  \r\n    // for Debug\r\n    !EnvAssociate.Light && (_self._setlog = function(){\r\n      if(!Lycabinet.DEBUG) return false;\r\n\r\n      const presets: CabinetEventType[] = [\r\n        'created','mounted', \r\n        'beforeLoad', 'beforeLocalLoad', 'localLoaded', 'loaded', \r\n        'loadFromCache',\r\n        'storageSync',\r\n        'setItem', 'writeLock', 'writeBackflow', \r\n        'getItem', 'removeItem', \r\n        'lazySave', \r\n        'beforeSave', 'beforeLocalSave', 'localSaved', 'saved', 'busy',\r\n        'beforeClear', 'beforeLocalClear', 'localCleared', 'cleared',\r\n        'error', 'destroyed',\r\n      ];\r\n  \r\n      new Set(Object.keys(subscriptions).concat(presets) ).forEach(item=>{\r\n        let testHandle = subscriptions[item] && subscriptions[item]._logHandle;\r\n        if(testHandle){\r\n          this._off(item, testHandle)\r\n        }\r\n        const logHandle = ()=>{\r\n          Lycabinet.DEBUG &&\r\n          console.log(`[Lycabinet${Lycabinet.SeparateLog?'-'+this.__root:''}]:Triggered the event: '${item}'`);\r\n        };\r\n\r\n        this._on(item, logHandle);\r\n        subscriptions[item]._logHandle = logHandle;\r\n      });\r\n      return true;\r\n    });\r\n    \r\n    _self._on(\"destroyed\", ()=>{\r\n      for(let item in subscriptions){\r\n        delete subscriptions[item];\r\n      }\r\n    });\r\n  });\r\n}","/**\r\n * Given a private cabinet for every set storage.\r\n * Cabinet Basement.\r\n */\r\n\r\nimport { DEBUG, is_Defined, is_PlainObject } from \"../utils/util\";\r\n\r\nexport function InitStore(Lycabinet){\r\n  const __cabinet = Object.create(null);\r\n  const __insTable = Object.create(null);\r\n  DEBUG && (window[\"__cabinet\"] = __cabinet);\r\n  const Proto = Lycabinet.prototype;\r\n\r\n  /**\r\n   * Get the exact cabinet of current instance.\r\n   */\r\n  Proto.getCabinet = function(){\r\n    return this.__storage;\r\n  }\r\n\r\n  /**\r\n   * Check cache consistent.\r\n   * Conclude whether the current cabinet is consistent with the inner cache.\r\n   * @returns { Boolean }\r\n   */\r\n  Proto.isIdentical = function(){\r\n    return this.__storage === __cabinet[this.__root];\r\n  }\r\n\r\n  Proto.hasStore = function(){\r\n    return is_Defined(__cabinet[this.__root]) && is_PlainObject(__cabinet[this.__root]);\r\n  }\r\n\r\n  /**\r\n   * Get the cached cabinet access.\r\n   * @returns {Plain Object} __cabinet ; The reference of the storage Object property been cached.\r\n   * Each instance is shared by the root key.\r\n   */\r\n  Proto.getStore = function(){\r\n    return __cabinet[this.__root];\r\n  }\r\n  \r\n  /**\r\n   * To initialize the cabinet cache. \r\n   * @param {Plain Object} cabinet \r\n   */\r\n  Proto.setStore = function(cabinet){\r\n    __cabinet[this.__root] = cabinet;\r\n  }\r\n\r\n  /**\r\n   * To clear the inner cache of cabinet.\r\n   * Defaultly prevent sharing elimination.\r\n   */\r\n  Proto.removeStore = function(){\r\n    if(this.options.useSharedCabinet \r\n      || !this.options.shareCabinet \r\n      || !this.isIdentical()\r\n      || __insTable[this.__root].size<=0\r\n    ) return false;\r\n    __cabinet[this.__root] = void 0;\r\n    return true;\r\n  }\r\n\r\n  Lycabinet.$removeStore = function(root: string){\r\n    __cabinet[root] = void 0;\r\n  }\r\n\r\n  DEBUG && (Lycabinet.$getStore = function(root: string){\r\n    return __cabinet[root];\r\n  });\r\n\r\n  Lycabinet.mixin((cabinetIns)=>{\r\n    cabinetIns._on(\"created\", ()=>{\r\n      if(!__insTable[cabinetIns.__root])\r\n        __insTable[cabinetIns.__root] = new Set();\r\n      __insTable[cabinetIns.__root].add(cabinetIns);\r\n    });\r\n    \r\n    cabinetIns._on(\"destoryed\", ()=>{\r\n      __insTable[cabinetIns.__root].delete(cabinetIns);\r\n      if(__insTable[cabinetIns.__root].size<=0)\r\n        __insTable[cabinetIns.__root] = void 0;\r\n    });\r\n  });\r\n}\r\n","/**\r\n * lycabinet.js\r\n * A slight JSON Type Object storage helper with good performance.\r\n * 一个适用于JSON对象数据存储的轻量辅助类。\r\n * @author Lozyue\r\n * @createdTime 2021-03-28\r\n */\r\n\r\nimport { ConstructOptions, AccessOptions, SubSet } from '@/typings/lycabinet';\r\nimport * as _STATUS from '@/utils/status';\r\nimport { \r\n  deepAssign, arbitraryFree, curveGet, curveSet,\r\n  is_Defined, is_PlainObject, is_Empty, is_String,\r\n  LogToken, DEBUG, deepConditionalAssign, \r\n} from '@/utils/util';\r\n\r\nexport function InitCore(Lycabinet){\r\n  // Constructor Options\r\n  Lycabinet.DEBUG = true;\r\n  Lycabinet.SeparateLog = false;\r\n\r\n  const Proto = Lycabinet.prototype;\r\n  /**\r\n   * The configuration initialization.\r\n   * @param { String } root \r\n   * @param { Object } options \r\n   */\r\n  Proto.__init = function(root: string, options: Partial<ConstructOptions> = {} ){\r\n\r\n    if(options.initStorage && !is_PlainObject(options.initStorage) ){\r\n      throw new Error(`${LogToken}The type of the provided option \"initStorage\" must be an Object!`);\r\n    }\r\n    if( !is_String(root)) \r\n      throw new Error(`${LogToken}The param \"root\" should be an string, than type ${typeof root}!`);\r\n    this.__root = (root || 'lycabinet') + ''; // The key in storage. Must be a string.\r\n\r\n    // default options.\r\n    const defaultOptions = {\r\n      root: this.__root,\r\n      autoload: true,\r\n      lazyPeriod : ~~(options.lazyPeriod as number) || 5000, // set the lazy period of lazySave methods.\r\n      saveMutex: true,\r\n      autoLazy: true, // Call lazy save automaticly when the save is busy. \r\n      logEvent: false, // use this to log event globally from scratch\r\n      useSharedCabinet: true, // use global shared cabinet\r\n      shareCabinet: true, // share the cabinet for global\r\n      // Weather use deepAssign to contact when load from outer data.\r\n      deepMerge: false, \r\n      customMerge: null, // Applying just on loading.\r\n      // local interfaces of storage\r\n      localInterface: {\r\n        database: window.localStorage,\r\n        getItem: \"getItem\",\r\n        setItem: \"setItem\",\r\n        removeItem: \"removeItem\",\r\n      }, \r\n      concurrent: !!(options.outerLoad || options.outerSave || options.outerClear),\r\n      outerLoad: null,\r\n      outerSave: null,\r\n      outerClear: null,\r\n    };\r\n    this.options = deepAssign(defaultOptions, options);\r\n    // Make the privilege.\r\n    this.__install(defaultOptions);\r\n    \r\n    // root event console log\r\n    if(defaultOptions.logEvent) this._setlog();\r\n\r\n    this.status = _STATUS.CREATED;\r\n    this._trigger(\"created\");\r\n    \r\n    if(defaultOptions.autoload) this._init(options.initStorage || Object.create(null) );\r\n  };\r\n\r\n  /**\r\n   * Initialize the cabinet storage before 'CURD' manipulation.\r\n   * If autoload is not setted, you should call this manually.\r\n   */\r\n  Proto._init = function(cabinet:null|Object = null){\r\n    const options = this.options;\r\n    cabinet = (cabinet || options.initStorage || Object.create(null)) as Object;\r\n\r\n    // write protection backflow\r\n    const writeBackflow = function(){\r\n      if(is_Empty(this.__tempStorage)) return;\r\n      // backflow\r\n      deepAssign(this.__storage, this.__tempStorage);\r\n      this.__tempStorage = Object.create(null);\r\n      this._trigger(\"writeBackflow\");\r\n    }\r\n    this._on(\"loaded\", writeBackflow);\r\n    this._on(\"cleared\", writeBackflow);\r\n\r\n    // override the options by the already existed cabinet.\r\n    // this is global shared with all the instance in the page.\r\n    const isLoadFromCache = options.useSharedCabinet && this.hasStore();\r\n    if(isLoadFromCache){\r\n      this.__storage = this.getStore();\r\n      // Sync status.\r\n      if(options.deepMerge){\r\n        deepConditionalAssign(cabinet, this.__storage, options.customMerge);\r\n      }else\r\n        Object.assign(cabinet, this.__storage);\r\n      this._trigger(\"loadFromCache\", this.__storage);\r\n    }\r\n    else{\r\n      this.__storage = this.__storage || cabinet;\r\n      if(options.shareCabinet)\r\n        this.setStore(this.__storage);\r\n    }\r\n\r\n    this.status = _STATUS.MOUNTED;\r\n    this._trigger(\"mounted\"); // Interior cabinet access is attainable.\r\n\r\n    if(!isLoadFromCache){\r\n      // Auto load. Only when the cabinet is in private using.\r\n      if(options.autoload) this.load(); // default using shallow assign.\r\n      else this.status = _STATUS.IDLE; // Amend the status.\r\n    } else {\r\n      this.status = _STATUS.IDLE; // Amend the status.\r\n    }\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Test the cabinet is busy or not.\r\n   */\r\n  Proto.isVacant = function(){\r\n    return this.status===_STATUS.IDLE;\r\n  }\r\n\r\n  /**\r\n   * Set an item with key.\r\n   * Added write protection on stage of loading and clearing.\r\n   * @param {*} keys \r\n   * @param {*} value \r\n   */\r\n  Proto.set = function(keys, value){\r\n    const MutexStatus = [_STATUS.LOADING, _STATUS.CLEARING];\r\n    // add write protection.    \r\n    if(MutexStatus.indexOf(this.status) > -1){\r\n      this._trigger(\"writeLock\");\r\n      this.__tempStorage = this.__tempStorage || (this.__tempStorage = Object.create(null));\r\n      curveSet(this.__tempStorage, keys.split('.'), value);\r\n      return this;\r\n    }\r\n\r\n    curveSet(this.__storage, keys.split('.'), value);\r\n    this._trigger('setItem', keys, value);\r\n    return this;\r\n  };\r\n\r\n  /**\r\n   * Get the value of an item by key.\r\n   * Please don't read from loading and clearing stream.\r\n   * @param {*} keys support dot-split obj pathes\r\n   */\r\n  Proto.get = function(keys){\r\n    let backValue = curveGet(this.__storage, keys.split('.'));\r\n    this._trigger('getItem', keys, backValue);\r\n    return backValue;\r\n  }\r\n\r\n  /**\r\n   * Delete an item by key.\r\n   */ \r\n  Proto.remove = function(keys: string|string[]){\r\n    let removed = false;\r\n    arbitraryFree(keys, (k)=>{\r\n      // Though it isn't disappeared immediately, But after JSON parse and stringify manipulations this will be cleared.\r\n      if(this.__storage.hasOwnProperty(k)){\r\n        this.set(k, void 0);\r\n        removed = true;\r\n      }\r\n    });\r\n    removed && this._trigger('removeItem', keys, removed);\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Delete the cabinet directly.\r\n   * But the data may still exist in memory(RAM).  \r\n   * @param {Boolean} onCloud \r\n   * @param {Boolean} concurrent Override the default options in `this.options.concurrent`\r\n   */\r\n  Proto.clear = function(option: SubSet<AccessOptions, \"deepMerge\"> & { reset?: boolean } = {}){\r\n    // merge default options.\r\n    const concurrent = is_Defined(option.concurrent)? option.concurrent: this.options.concurrent;\r\n    const onCloud = (is_Defined(option.onCloud)? option.onCloud: !!this.options.outerClear) as boolean;\r\n    this.status = _STATUS.LOADING;\r\n    this._trigger('beforeClear');\r\n    \r\n    // Local clear\r\n    let localClear = ()=>{\r\n      const IgnoreLocal = onCloud && !concurrent;\r\n      this._trigger('beforeLocalClear', IgnoreLocal); // give an status token before invoke.\r\n\r\n      if(IgnoreLocal){\r\n        DEBUG && console.log(`${LogToken}The local clear action is ignored by options: concurrent:false.`);\r\n        return this;\r\n      }\r\n      const localApi = this.options.localInterface;\r\n      localApi.database[localApi.removeItem]( this.__root );\r\n      // trigger hook event after call local database to clear the Item.\r\n      this._trigger('localCleared', this.__root); // Give the param of the remove target. \r\n    }\r\n\r\n    const toEnd = (isSuccess: boolean)=>{\r\n      this.status = _STATUS.IDLE;\r\n      // Callback\r\n      option.onceDone && option.onceDone(isSuccess, onCloud);\r\n      this._trigger('cleared', onCloud, concurrent);\r\n    };\r\n\r\n    // Cloud clear\r\n    const pack = [this.__root, this.__storage];\r\n    const onSuccess = ()=>{\r\n      toEnd(true);\r\n    }\r\n    const onError = (msg, reason='cloudClearings')=>{\r\n      toEnd(false);\r\n\r\n      if(this._trigger(\"error\", \"clear\", reason) !== true ){\r\n        onCloud && console.error(`${LogToken}Failed tfo Clear the cabinet \"${this.__root}\" on cloud. ${msg}`);\r\n      }\r\n    }\r\n\r\n    // handle this async or asyn easily.\r\n    try{\r\n      // Reset the inner cabinet to vacant Object.\r\n      if(option.reset){\r\n        Reflect.ownKeys(this.__storage).forEach(item=>{\r\n          delete this.__storage[item];\r\n        });\r\n      }\r\n\r\n      localClear();\r\n      if(onCloud) \r\n        this.options.outerClear(pack, onSuccess, onError);\r\n      else {\r\n        toEnd(true);\r\n      }\r\n    } catch(e){\r\n      onError(e, \"unknown\");\r\n    }\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Load the cabinet on initialization.\r\n   * The local load is faster than cloud.\r\n   * @param { Boolean } onCloud \r\n   * @param { Boolean } concurrent Override the default options in `this.options.concurrent`\r\n   * @param { Boolean } deepMerge Using deepAssign instead of Object.assign to merge the data from local and cloud.\r\n   */\r\n  Proto.load = function(option: AccessOptions & { disableMerge?: boolean} = {}){\r\n    // merge default options.\r\n    const concurrent = is_Defined(option.concurrent)? option.concurrent: this.options.concurrent;\r\n    const onCloud = (is_Defined(option.onCloud)? option.onCloud: !!this.options.outerLoad) as boolean;\r\n    const deepMerge = is_Defined(option.deepMerge)? ~~(option.deepMerge as Boolean): this.options.deepMerge;\r\n    this.status = _STATUS.LOADING;\r\n    this._trigger(\"beforeLoad\");\r\n\r\n    // Local load \r\n    let localLoad = ()=>{\r\n      let localTemp = null;\r\n      const IgnoreLocal = onCloud && !concurrent;\r\n      this._trigger('beforeLocalLoad', IgnoreLocal); // give an status token before invoke.\r\n\r\n      if(IgnoreLocal){\r\n        DEBUG && console.log(\"${LogToken}The local load action is ignored by options: concurrent=false.\");\r\n        return this;\r\n      }\r\n      const localApi = this.options.localInterface;\r\n      \r\n      let initialData = localApi.database[localApi.getItem]( this.__root );\r\n      // trigger hook event after call local database to parse the value. \r\n      // Should have a return value in event. (data)=>{ return handle(data); }\r\n      initialData = this._trigger('localLoaded', initialData); // Only take effect on the last element.\r\n\r\n      localTemp = JSON.parse( initialData );\r\n      if(deepMerge){\r\n        if(option.disableMerge)\r\n          deepAssign(this.__storage, localTemp);\r\n        else\r\n          deepConditionalAssign(this.__storage, localTemp, this.options.customMerge);\r\n      }else\r\n        Object.assign(this.__storage, localTemp);\r\n    };\r\n\r\n    const toEnd = (isSuccess: boolean)=>{\r\n      this.status = _STATUS.IDLE;\r\n      // Callback\r\n      option.onceDone && option.onceDone(isSuccess, onCloud);\r\n      this._trigger('loaded', onCloud, concurrent);\r\n    }\r\n\r\n    // Cloud load\r\n    const pack = [this.__root, this.__storage];\r\n    const onSuccess = (data)=>{\r\n      if(!is_Defined(data) || !is_PlainObject(data))\r\n        throw new Error(`${LogToken}Load cabinet with empty 'data' which type is ${typeof data}`);\r\n        \r\n      if(deepMerge){\r\n        if(option.disableMerge)\r\n          deepAssign(this.__storage, data);\r\n        else\r\n          deepConditionalAssign(this.__storage, data, this.options.customMerge);\r\n      }else \r\n      // shallow assign makes cloud weight heavier.\r\n        Object.assign(this.__storage, data);\r\n      \r\n      toEnd(true);\r\n    }\r\n    const onError = (msg, reason='cloudLoadings')=>{\r\n      toEnd(false);\r\n\r\n      if(this._trigger(\"error\", \"load\", reason) !== true){\r\n        onCloud && console.error(`${LogToken}Failed to Load the cabinet \"${this.__root}\" on cloud. ${msg}`);\r\n      }\r\n    }\r\n\r\n    // handle this async or asyn easily.\r\n    try{\r\n      localLoad();\r\n      if(onCloud) \r\n        this.options.outerLoad(pack, onSuccess, onError);\r\n      else {\r\n        toEnd(true);\r\n      }\r\n    } catch(e){\r\n      onError(e, \"unknown\");\r\n    }\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Save the cabinet to database or cloud.\r\n   * The event `localSaved` is called before real action for storage hook.\r\n   * @param {*} onCloud \r\n   * @param {Boolean} concurrent Override the default options in `this.options.concurrent`\r\n   */\r\n  Proto.save = function(option: SubSet<AccessOptions, 'deepMerge'> = {}){\r\n    // merge default options.\r\n    const onCloud = (is_Defined(option.onCloud)? option.onCloud: !!this.options.outerSave) as boolean;\r\n    const concurrent = is_Defined(option.concurrent)? option.concurrent: this.options.concurrent;\r\n    \r\n    // check the status for mutex protection\r\n    let check = this.options.saveMutex && !this.isVacant();\r\n    this._trigger(\"beforeSave\", check);\r\n    if( check ){\r\n      DEBUG && console.log(`${LogToken}The 'save' manipulation is deserted for busy. Current Status: ${this.status} .Set 'saveMutex' false to disable it.`);\r\n      this._trigger(\"busy\", this.status);\r\n      this.options.autoLazy && this.lazySave(onCloud, concurrent);\r\n      return this;\r\n    }\r\n    \r\n    this.status = _STATUS.SAVING;\r\n\r\n    // Local save \r\n    let localSave = ()=>{\r\n      const IgnoreLocal = onCloud && !concurrent;\r\n      this._trigger('beforeLocalSave', IgnoreLocal); // give an status token before invoke.\r\n\r\n      if(IgnoreLocal){\r\n        DEBUG && console.log(\"${LogToken}The local save action is ignored by options: concurrent=false.\");\r\n        return this;\r\n      }\r\n      // trigger hook event beforeLocalSave. Should have a return value in event. (data)=>{ return handle(data); }\r\n      let finalData = JSON.stringify(this.__storage );\r\n      // trigger hook event before call local database to save the value for data interceptor.\r\n      finalData = this._trigger('localSaved', finalData); // Only take effect on the last element.\r\n\r\n      const localApi = this.options.localInterface;\r\n      localApi.database[localApi.setItem](this.__root, finalData);\r\n    };\r\n    \r\n    const toEnd = (isSuccess: boolean)=>{\r\n      this.status = _STATUS.IDLE;\r\n      // Callback\r\n      option.onceDone && option.onceDone(isSuccess, onCloud);\r\n      this._trigger('saved', onCloud, concurrent);\r\n    }\r\n\r\n    // Cloud save\r\n    const pack = [this.__root, this.__storage];\r\n    const onSuccess = ()=>{\r\n      toEnd(true);\r\n    }\r\n    const onError = (msg, reason=\"cloudSavings\")=>{\r\n      toEnd(false);\r\n\r\n      if(this._trigger(\"error\", \"save\", reason) !== true){\r\n        onCloud && console.error(`${LogToken}Failed to Save the cabinet \"${this.__root}\" on cloud. ${msg}`);\r\n      }\r\n    }\r\n\r\n    // handle this async or sync easily.\r\n    try{\r\n      localSave();\r\n      if(onCloud) \r\n        this.options.outerSave(pack, onSuccess, onError);\r\n      else {\r\n        toEnd(true);\r\n      }\r\n    } catch(e){\r\n      onError(e, 'unknown');\r\n    }\r\n    return this;\r\n  }\r\n  \r\n  /**\r\n   * Foreach methods support.\r\n   * Iterate the first hierarchy with callback.\r\n   * @param {Function: (item, key, cabinet)=>any }} callback with two params\r\n   */\r\n  Proto.forEach = function(callback: (item: any, key: string, cabinet: Object)=>any){\r\n    let item;\r\n    const cabinet = this.__storage;\r\n    for(let key in cabinet){\r\n      item = cabinet[key];\r\n      callback(item, key, cabinet); // only two params.\r\n    }\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Map methods support.\r\n   * Iterate the first hierarchy with callback.\r\n   * @param {Function: (item, key, cabinet)=>any }} callback  with two params\r\n   * @return { Object } cabinet\r\n   */\r\n  Proto.map = function(callback: (item: any, key: string, cabinet: Object)=>any){\r\n    let item;\r\n    const cabinet = this.__storage;\r\n    for(let key in cabinet){\r\n      item = cabinet[key];\r\n      cabinet[key] = callback(item, key, cabinet); // only two params.\r\n    }\r\n    return cabinet;\r\n  }\r\n\r\n  /**\r\n   * For custom destroy.\r\n   * Call it to clear the sideEffect produce by kinds of plugins.\r\n   */\r\n  Proto.destroy = function(autoClear = false){\r\n    if(autoClear){\r\n      this.clear({\r\n        reset: true,\r\n        onCloud: false,\r\n        concurrent: false,\r\n      });\r\n    }\r\n    \r\n    this.removeStore();\r\n    this.status = _STATUS.DESTROYED;\r\n    this._trigger(\"destroyed\");\r\n  }\r\n\r\n}\r\n","/**\r\n * Lycabinet Status.\r\n */\r\n\r\nconst CREATED = 'created';\r\nconst MOUNTED = 'mounted';\r\nconst IDLE = 'idle';\r\nconst LOADING = 'loading';\r\nconst SAVING = 'saving';\r\nconst CLEARING = 'clearing';\r\nconst DESTROYED = 'destroyed';\r\n\r\nexport {\r\n  CREATED,\r\n  IDLE,\r\n  LOADING,\r\n  SAVING,\r\n  CLEARING,\r\n  MOUNTED,\r\n  DESTROYED\r\n};\r\n","/**\r\n * Lazy methods support.\r\n * @param {*} Lycabinet \r\n */\r\nimport { DEBUG } from \"@/utils/util\";\r\n\r\nexport function InitLazyDepartment(Lycabinet){\r\n  \r\n  /**\r\n   * Add lazySave support.\r\n   * The params is the same to save methods.\r\n   */\r\n  Lycabinet.prototype.lazySave = (function(){\r\n    var lastTime = 0; // throttle\r\n    var timerHandle: NodeJS.Timeout; // debounce\r\n    return function(...params){\r\n      var nowTime = new Date().getTime();\r\n      // The gap is not so accurate but enough.\r\n      let judge = (nowTime - lastTime) > this.options.lazyPeriod;\r\n      this._trigger(\"lazySave\", judge);\r\n\r\n      clearTimeout(timerHandle);\r\n      if (judge) {\r\n        // Use default settings\r\n        DEBUG && console.log(\"Lazy executed!\", nowTime, lastTime, judge)\r\n        this.save(...params);\r\n      } else {\r\n        timerHandle = setTimeout(()=>{\r\n          this.save(...params);\r\n        }, nowTime - lastTime);\r\n      }\r\n      lastTime = nowTime;\r\n      return this;\r\n    }\r\n  })();\r\n\r\n  /**\r\n   * Just calling lazySave after save called.\r\n   * @param {*} key \r\n   * @param {*} value \r\n   * @param {...any} params parameters to lazySave (). \r\n   */\r\n  Lycabinet.prototype.lazySet = function(key, value, ...params){\r\n    this.set(key, value).lazySave(...params);\r\n    return this;\r\n  }\r\n}","/**\r\n * 提供接口利用 laction 作为支持, 影响后续所有实例\r\n * 利用Laction 进行 lazySave 性能进一步优化和增强为节流防抖双支持模式.\r\n * \r\n * // Usage:\r\n * import Lycabinet\r\n * // Existed instance of Laction\r\n * lactionIns.use(Lycabinet);\r\n * \r\n * When immbedding enabled, you should manually call the `destroy` method\r\n *  to discard the instance(Especially there is more than one instance).\r\n */\r\n\r\nimport { DEBUG, deepSupplement } from \"../utils/util\";\r\n\r\nexport function initImbedding(Lycabinet){\r\n  // Provide as a Laction plugins.\r\n  Lycabinet.install = function(lactionIns, options){\r\n    // Add mixin. Should be called before lycabinet instantiation.\r\n    Lycabinet.mixin(function(lycabinetIns){\r\n      // add some actions for laction conjunction.\r\n      deepSupplement(lycabinetIns.options, {\r\n        useLaction:{\r\n          // the target orbit of bubbled lazy message \r\n          lazyOrbitId: -1, // the last orbit. see: https://github.com/lozyue/laction.git\r\n        }\r\n      });\r\n\r\n      let LazyRootKey = lycabinetIns.__root+'_lazy';\r\n      // Accept pre-redundant postfix.\r\n      const LazyKey = lactionIns.testHookName(LazyRootKey, true);\r\n      lycabinetIns.getLazyKey = ()=>LazyKey;\r\n      lycabinetIns._lazyKey = LazyKey;\r\n\r\n      // Register the lazy methods hook.\r\n      lactionIns.registerHook(\r\n        {\r\n          name: LazyKey,\r\n          // apply period throttle.s\r\n          once: true, \r\n          // apply period debounce.\r\n          debounce: true, \r\n          // level: 3, // 1 Root 消息级钩子 // 默认普通消息\r\n          action: (...params)=>{            \r\n            lycabinetIns.save(...params) \r\n          },\r\n        },\r\n      );\r\n\r\n      lycabinetIns._on(\"destroyed\", ()=>{\r\n        lactionIns.unregisterHook(LazyKey);\r\n      });\r\n    });\r\n\r\n    /**\r\n     * lazySave method update\r\n     * OverWrite lazy methods with laction instances. \r\n     *  And give it better performance and even visualizaztion.\r\n     * @param {*} lazyOrbitId the added params for laction. \r\n     */\r\n    Lycabinet.prototype.lazySave = function(...params){\r\n      // Get the key of Auto generated.\r\n      params.unshift( this._lazyKey );\r\n      // bubble with auto period throttle and debounce.\r\n      \r\n      lactionIns.bubble(params, this.options.useLaction.lazyOrbitId, false);\r\n      this._trigger(\"lazySave\");\r\n      return this;\r\n    };\r\n  };\r\n}\r\n","/**\r\n * Add alias to some methods.\r\n * To custom the using habit for general users.\r\n */\r\n\r\nexport function initAlias(Lycabinet){\r\n  const Proto = Lycabinet.prototype;\r\n  \r\n  Proto.delete = Proto.remove;\r\n\r\n  Proto.read = Proto.get;\r\n  Proto.write = Proto.set;\r\n\r\n  Proto.storage = Proto.getCabinet;\r\n\r\n  Proto.isConsistent = Proto.isIdentical;\r\n}","/**\r\n * Argument the robustness of the JSON data process.\r\n * And preserve the atomicity when there is multi-tabs opened by user.\r\n * Like delete the Item in Storage if it is vacant.\r\n */\r\n\r\nimport { LycabinetStatic } from \"@/typings/lycabinet\";\r\nimport { addStoreListener, arrayIndex, DEBUG, objectSupplement, removeArrayItem } from \"../utils/util\";\r\n\r\nconst ParticalToken = 'cabinetSyncTabs';\r\nconst TokenSeparator = '|';\r\n\r\nexport function addCheck(Lycabinet){\r\n  /**\r\n   * JSON analysis argumented.\r\n   */\r\n  Lycabinet.mixin(function(cabinetIns){\r\n    cabinetIns._on(\"localLoaded\", function(finalData, results){\r\n      let final = results.length? arrayIndex(results, -1): finalData;\r\n      // add pre-check for JSON Parse.\r\n      if(!final) final = '{}';\r\n      return final;\r\n    });\r\n    cabinetIns._on(\"localSaved\", function(finalData, results){\r\n      let final = results.length? arrayIndex(results, -1): finalData;\r\n      return final;\r\n    });\r\n  });\r\n\r\n  /**\r\n   * Add a dirty flag.\r\n   */\r\n  Lycabinet.mixin(function(cabinetIns){\r\n    // This is not that precious. Since user can directly modify the __storage Object without a record.\r\n    cabinetIns._on(\"setItem\", function(){\r\n      this._dirty = true;\r\n    });\r\n    cabinetIns._on(\"saved\", function(){\r\n      this._dirty = false;\r\n    })\r\n  });\r\n\r\n  /**\r\n   * Listening the storage event from other tabs(pages)\r\n   *  Custom Events: `storageSync`\r\n   */\r\n  var localContext: Array<LycabinetStatic> = [];\r\n  const cabinetSyncTab = (eve)=>{\r\n    let cabinetIns: LycabinetStatic;\r\n\r\n    let toMatchRoot = eve.key; \r\n    if(ParticalToken===eve.key){\r\n      toMatchRoot = eve.newValue.slice( - eve.newValue.lastIndexOf(TokenSeparator) );\r\n    };\r\n\r\n    for(let index=0; index<localContext.length; index++){\r\n      cabinetIns = localContext[index];\r\n      if(!cabinetIns.options.autoNotifyTabs){\r\n        DEBUG && console.log(\"TabSync is disabled!\");\r\n        return;\r\n      }\r\n\r\n      // Do not do redundant reload if current cabinet is shared by another.\r\n      // We think that in one page the cabinet has the same root is always shared, but there are troubles if\r\n      //  the first instance is collected by GC.\r\n      if(cabinetIns.useLoadCache) continue;\r\n\r\n      // Reload. By default using deeepMerge mode.\r\n      if([cabinetIns.__root].indexOf(toMatchRoot) > -1){\r\n        DEBUG && console.log(\"[Lycabinet]: Synchronizing data from other tabs...\");\r\n        // merge data using default options.\r\n        (cabinetIns.load as Function)({\r\n          onCloud: false, \r\n          concurrent: true, \r\n          deepMerge: true,\r\n          disableMerge: true,\r\n        }); // Considering of the latency on cloud, we only synchronize the data locally.\r\n        (cabinetIns._trigger as Function)(\"storageSync\");\r\n        break;\r\n      }\r\n    }\r\n  };\r\n  addStoreListener( cabinetSyncTab );\r\n  \r\n\r\n  /**\r\n   * Add auto tab synchronize listener options.\r\n   */\r\n  Lycabinet.mixin(function(cabinetIns){\r\n    // save the localContext\r\n    localContext.push(cabinetIns);\r\n    // Remove the context.\r\n    cabinetIns._on(\"destroyed\", ()=>{\r\n      removeArrayItem( localContext, cabinetIns);\r\n    });\r\n\r\n    // Add cache check token.\r\n    cabinetIns._on(\"loadFromCache\", function(){\r\n      this.useLoadCache = true; \r\n    });\r\n\r\n    // add options for custom database which is not localStorage.\r\n    objectSupplement(cabinetIns.options, {\r\n      autoNotifyTabs: true,\r\n    });\r\n\r\n    cabinetIns._on(\"saved\", function(onCloud, concurrent){\r\n      if(this.options.autoNotifyTabs){\r\n        const IgnoreLocal = onCloud && !concurrent;\r\n        if(IgnoreLocal){\r\n          return false;\r\n        }\r\n\r\n        this.notifyTabs();\r\n      }\r\n    });\r\n  });\r\n\r\n  /**\r\n   * If the database in configuration is not `LocalStorage` (eg Env `sessionStorage`)\r\n   * You should call this method to notify the other pages or set prop `autoNotifyTabs` to true.\r\n   */\r\n  Lycabinet.prototype.notifyTabs = function(){\r\n    const randomToken = new Date().getTime();\r\n    // this will give other pages a notifycation.\r\n    const storage = window.localStorage;\r\n    try{\r\n      storage.setItem(ParticalToken, `${this.__root}${TokenSeparator}${randomToken}`);\r\n    } catch(err){\r\n      if(err instanceof DOMException && (\r\n        // everything except Firefox\r\n        err.code === 22 ||\r\n        // Firefox\r\n        err.code === 1014 ||\r\n        // test name field too, because code might not be present\r\n        // everything except Firefox\r\n        err.name === 'QuotaExceededError' ||\r\n        // Firefox\r\n        err.name === 'NS_ERROR_DOM_QUOTA_REACHED') &&\r\n        // acknowledge QuotaExceededError only if there's something already stored\r\n        (storage && storage.length !== 0)\r\n      )\r\n        console.error(\"[lycabinet]: Sync storage from tabs failed cause LocalStorage is not supportted!\", err);\r\n    }\r\n  }\r\n}\r\n","/**\r\n * Using a preset dictionary to compress the json data for storage or transfer. \r\n */\r\n\r\nimport { arrayIndex } from \"../utils/util\";\r\n\r\nexport function addZip(Lycabinet){\r\n  Lycabinet.mixin(function(cabinetIns){\r\n    cabinetIns._on(\"localLoaded\", function(finalData, results){\r\n      let final = results.length? arrayIndex(results, -1): finalData;\r\n      // todo...\r\n      // console.log(`beforeLocalLoad: length:${final.length}`, final, final.replaceAll(`'`, `.`));\r\n      return final;\r\n    });\r\n    cabinetIns._on(\"localSaved\", function(finalData, results){\r\n      let final = results.length? arrayIndex(results, -1): finalData;\r\n      // todo...\r\n      // console.log(`beforeLocalSave: length:${final.length}`, final, final.replaceAll(`.`, `'`));\r\n      return final;\r\n    });\r\n  });\r\n}\r\n"],"names":["__webpack_require__","exports","definition","key","o","Object","defineProperty","enumerable","get","obj","prop","prototype","hasOwnProperty","call","arrayIndex","arr","index","undefined","length","DEBUG","console","error","toString","curveSet","source","objPathes","value","interim","item","is_Defined","is_Object","is_Function","addStoreListener","invokeQueue","window","addEventListener","eve","forEach","func","invoke","remove","removeArrayItem","push","deepAssign","objs","merged","reduce","target","is_PlainObject","deepConditionalAssign","condition","deepSupplement","supplement","current","deepClone","val","substituteObj","create","cloneFunc","res","is_Array","slice","constructor","v","Array","isArray","Function","indexOf","splice","LogToken","CustomFilter","cabinet","Includes","Excludes","filtered","includesKeyMap","associatedKey","split","currentStore","targetStore","i","assign","excludesKeyMap","pointer","log","onSetted","deepConvert","deepWatch","shallowWatch","plainObjQueue","iterate","unshift","ref","convert","internalValue","_parent","triggers","propConfig","configurable","writable","$addListener","onchange","$removeListener","handle","AccessQueue","hook","refValue","Proxy","receiver","info","set","newValue","rawValue","Error","Lycabinet","options","this","__init","apply","_mixins","mixin","mixinFunc","__install","InitMixin","preOwnner","_self","subscriptions","_on","name","_off","actions","_lock","Promise","resolve","then","_trigger","params","_counter","results","preLen","temp","_ready","instantOnTriggered","subs","_isHappened","handleFunc","_next","counts","_count","_setlog","Set","keys","concat","testHandle","_logHandle","logHandle","SeparateLog","__root","InitEventSystem","__cabinet","__insTable","Proto","getCabinet","__storage","isIdentical","hasStore","getStore","setStore","removeStore","useSharedCabinet","shareCabinet","size","$removeStore","root","$getStore","cabinetIns","add","delete","InitStore","initStorage","str","String","defaultOptions","autoload","lazyPeriod","saveMutex","autoLazy","logEvent","deepMerge","customMerge","localInterface","database","localStorage","getItem","setItem","removeItem","concurrent","outerLoad","outerSave","outerClear","status","_init","writeBackflow","__tempStorage","isLoadFromCache","load","isVacant","backValue","curveGet","removed","input","k","clear","option","onCloud","localClear","IgnoreLocal","localApi","toEnd","isSuccess","onceDone","pack","onSuccess","onError","msg","reason","reset","Reflect","ownKeys","e","localLoad","localTemp","initialData","JSON","parse","disableMerge","data","save","check","lazySave","localSave","finalData","stringify","callback","map","destroy","autoClear","InitCore","timerHandle","lastTime","nowTime","Date","getTime","judge","clearTimeout","setTimeout","lazySet","InitLazyDepartment","install","lactionIns","lycabinetIns","useLaction","lazyOrbitId","LazyRootKey","LazyKey","testHookName","getLazyKey","_lazyKey","registerHook","once","debounce","action","unregisterHook","bubble","initImbedding","read","write","storage","isConsistent","initAlias","opt","includes","excludes","setFilter","_this","$filter","addFilter","initObserver","lazy","initWatch","$active","pathList","deep","shallow","innerTarget","kname","warn","pathName","addObserver","final","_dirty","localContext","toMatchRoot","lastIndexOf","autoNotifyTabs","useLoadCache","objectSupplement","notifyTabs","randomToken","err","DOMException","code","addCheck","addZip"],"sourceRoot":""}